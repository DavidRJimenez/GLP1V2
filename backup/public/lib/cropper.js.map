{"version":3,"file":"cropper.js","mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACuG;AACxE;AAC8H;AAC3H;;AAElC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,4DAAa;AACb,+DAAgB;AAChB,0DAAW;AACX,4DAAa;AACb,2DAAY;AACZ,+DAAgB;AAChB,2DAAY;AACZ,4DAAa;AACb;AACA;AACA;AACA,YAAY,wDAAQ;AACpB;AACA;AACA,aAAa,yDAAS;AACtB;AACA;AACA;AACA,gDAAgD;AAChD;AACA,gBAAgB,gBAAgB;AAChC,cAAc,YAAY;AAC1B;AACA,gBAAgB,wDAAQ;AACxB;AACA;AACA,iBAAiB,yDAAS;AAC1B;AACA;AACA;AACA,aAAa,yDAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,MAAM;AACrB;AACA;AACA;AACA;AACA,gBAAgB,WAAW;AAC3B,wBAAwB,wDAAQ;AAChC;AACA;AACA,mFAAmF,MAAM;AACzF;AACA,yDAAyD,yDAAa;AACtE;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,0DAAc;AAC1D;AACA;AACA,4CAA4C,yDAAa;AACzD;AACA;AACA,4CAA4C,6DAAiB;AAC7D;AACA;AACA,+CAA+C,6DAAiB;AAChE;AACA;AACA;;AAEgD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC/GhD;AACA;AACA;AACA;AACA;AACA,0BAA0B,UAAU;AACpC,6BAA6B,UAAU;AACvC,wBAAwB,UAAU;AAClC,0BAA0B,UAAU;AACpC,yBAAyB,UAAU;AACnC,6BAA6B,UAAU;AACvC,yBAAyB,UAAU;AACnC,0BAA0B,UAAU;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,GAAG;AACd,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA,QAAQ,iBAAiB;AACzB;AACA;AACA,WAAW,GAAG;AACd,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,cAAc;AAC9B,gBAAgB,YAAY;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,SAAS,gDAAgD;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ,WAAW,aAAa;AACxB,WAAW,QAAQ;AACnB,WAAW,oCAAoC;AAC/C,WAAW,sBAAsB;AACjC;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,IAAI;AACJ,WAAW,aAAa;AACxB,WAAW,QAAQ;AACnB,WAAW,oCAAoC;AAC/C,WAAW,yBAAyB;AACpC;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,WAAW,aAAa;AACxB,WAAW,QAAQ;AACnB,WAAW,oCAAoC;AAC/C,WAAW,yBAAyB;AACpC;AACA;AACA,8DAA8D,cAAc,YAAY;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ,WAAW,aAAa;AACxB,WAAW,QAAQ;AACnB,WAAW,GAAG;AACd,WAAW,iBAAiB;AAC5B,aAAa,SAAS;AACtB;AACA;AACA,kGAAkG,0BAA0B,QAAQ;AACpI;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,WAAW,UAAU;AACrB,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB,aAAa,QAAQ;AACrB;AACA;AACA,YAAY,kBAAkB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ,WAAW,eAAe;AAC1B,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa,QAAQ;AACrB;AACA;AACA,YAAY,cAAc;AAC1B,UAAU,gBAAgB;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE2+B;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACpT96B;AACM;AACF;AACA;AACE;AACM;AACV;AACU;AACN;;;;;;;;;;;;;ACRmE;;AAEtI,6BAA6B,uBAAuB;;AAEpD;AACA;AACA;AACA;AACA;AACA,mCAAmC,kDAAM,2BAA2B,kDAAM,iCAAiC,2FAA+C;AAC1J;AACA;AACA,kBAAkB,yBAAyB,iBAAiB,kBAAkB,OAAO,EAAE,MAAM;AAC7F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,2DAAW;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,2DAAW;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,qDAAK;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,2DAAW;AACxC;AACA,iBAAiB,2DAAW;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,wDAAQ;AACxB;AACA,+BAA+B,MAAM;AACrC;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,iBAAiB,YAAY;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,iBAAiB,gCAAgC;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,GAAG;AAClB,eAAe,iBAAiB;AAChC,iBAAiB,SAAS;AAC1B;AACA;AACA,eAAe,oDAAI;AACnB;AACA;AACA;AACA,eAAe,UAAU;AACzB,iBAAiB,SAAS;AAC1B;AACA;AACA,eAAe,wDAAQ;AACvB;AACA;AACA;AACA,QAAQ;AACR,eAAe,eAAe;AAC9B,eAAe,QAAQ;AACvB;AACA;AACA,YAAY,wDAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,2DAAW;AAC1B,YAAY,sDAAU,IAAI,kDAAM,oBAAoB,kDAAM;AAC1D;AACA;AACA;AACA;AACA;;AAEqC;;;;;;;;;;;;;;AC9OS;AACoV;;AAElY,mBAAmB,cAAc,iBAAiB,gBAAgB,gBAAgB,kBAAkB,kBAAkB,2BAA2B,yBAAyB,sBAAsB,iBAAiB,oBAAoB,sBAAsB,yLAAyL,iEAAiE,oCAAoC,0BAA0B,kBAAkB,oBAAoB,wBAAwB,SAAS,WAAW,mBAAmB,cAAc,OAAO,oBAAoB,kBAAkB,QAAQ,MAAM;;AAEjuB,4BAA4B,wDAAc;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,uDAAW;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,kDAAE,OAAO,8DAAkB;AACvC;AACA;AACA;AACA,YAAY,kDAAE,qBAAqB,8DAAkB;AACrD;AACA;AACA;AACA,YAAY,kDAAE,qBAAqB,4DAAgB;AACnD;AACA;AACA;AACA,YAAY,kDAAE,OAAO,uDAAW;AAChC;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,YAAY,mDAAG,OAAO,8DAAkB;AACxC;AACA;AACA;AACA,YAAY,mDAAG,qBAAqB,8DAAkB;AACtD;AACA;AACA;AACA,YAAY,mDAAG,qBAAqB,4DAAgB;AACpD;AACA;AACA;AACA,YAAY,mDAAG,OAAO,uDAAW;AACjC;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,gBAAgB,wBAAwB;AACxC;AACA;AACA;AACA;AACA,SAAS,wDAAQ,gCAAgC,wDAAQ;AACzD;AACA;AACA;AACA;AACA,gBAAgB,YAAY;AAC5B;AACA;AACA,wDAAwD,2BAA2B;AACnF;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA,oBAAoB,8BAA8B;AAClD;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,qBAAqB,4DAAgB;AACrC;AACA,iBAAiB,yDAAS;AAC1B,sEAAsE,4DAAgB;AACtF;AACA,uBAAuB,8DAAkB;AACzC;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,qBAAqB;AACrC,yCAAyC,uDAAW;AACpD;AACA;AACA,uBAAuB,6DAAiB;AACxC;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,wDAAwD,2BAA2B;AACnF;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,aAAa;AACb;AACA;AACA,oBAAoB,8BAA8B;AAClD;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,4DAAgB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,yDAAa;AAC7C;AACA;AACA;AACA;AACA;AACA,gCAAgC,wDAAY;AAC5C;AACA;AACA;AACA;AACA;AACA,gCAAgC,uDAAW;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,8BAA8B,uDAAW;AACzC,uBAAuB,wDAAY;AACnC;AACA,aAAa;AACb;AACA;AACA;AACA,gBAAgB,qBAAqB;AACrC,yCAAyC,uDAAW;AACpD;AACA;AACA,uBAAuB,4DAAgB;AACvC;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,wDAAwD,aAAa;AACrE;AACA,aAAa;AACb;AACA;AACA,oBAAoB,gBAAgB;AACpC;AACA;AACA;AACA;AACA,2BAA2B,uDAAW;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,mBAAmB,wDAAY;AAC/B,oBAAoB,wDAAY;AAChC;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;AACA;AACA,eAAe,QAAQ;AACvB,iBAAiB,eAAe;AAChC;AACA;AACA,YAAY,wDAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,UAAU;AACzB,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,6DAAa;AAC7B,oBAAoB,gEAAgB,mBAAmB,gEAAgB;AACvE,mBAAmB,gBAAgB,EAAE,gEAAgB;AACrD;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,uEAAuE,yDAAa;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,6DAAa,aAAa,0DAAU;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA,sBAAsB,0DAAc;AACpC;;AAEoC;;;;;;;;;;;;;;AChcU;AACmR;;AAEjU,mBAAmB,qBAAqB,IAAI,cAAc,YAAY,0BAA0B,yBAAyB,uBAAuB,sBAAsB,WAAW;;AAEjL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,wDAAc;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,gBAAgB,SAAS;AACzB,wDAAwD,0DAAc;AACtE;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,kDAAE,UAAU,8DAAkB;AAC1C,YAAY,kDAAE,UAAU,4DAAgB;AACxC,YAAY,kDAAE,UAAU,wDAAY;AACpC;AACA;AACA,QAAQ,kDAAE,SAAS,sDAAU;AAC7B;AACA;AACA;AACA,gBAAgB,kBAAkB;AAClC;AACA;AACA,gBAAgB,mDAAG,UAAU,8DAAkB;AAC/C;AACA;AACA;AACA,gBAAgB,mDAAG,UAAU,4DAAgB;AAC7C;AACA;AACA;AACA,gBAAgB,mDAAG,UAAU,wDAAY;AACzC;AACA;AACA;AACA;AACA,YAAY,mDAAG,SAAS,sDAAU;AAClC;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,SAAS;AACzB;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,UAAU;AAC1B,gBAAgB,SAAS;AACzB;AACA,oBAAoB,eAAe;AACnC,kBAAkB,SAAS;AAC3B,2BAA2B,4DAAgB;AAC3C;AACA,6BAA6B,yDAAa;AAC1C;AACA;AACA,6BAA6B,wDAAY;AACzC;AACA;AACA,6BAA6B,uDAAW;AACxC;AACA;AACA;AACA,qBAAqB,uDAAW;AAChC;AACA;AACA;AACA,wFAAwF,6DAAiB;AACzG;AACA;AACA,kFAAkF,6DAAiB;AACnG;AACA;AACA,kEAAkE,mBAAmB,6DAAiB,EAAE;AACxG;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,yDAAa;AAClC;AACA;AACA,oCAAoC,OAAO;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,wDAAY;AACjC;AACA;AACA,8FAA8F,6DAAiB;AAC/G;AACA;AACA;AACA,wCAAwC,OAAO;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,4DAAgB;AACrC;AACA,gCAAgC,SAAS;AACzC,8BAA8B,QAAQ;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,UAAU;AACzB,iBAAiB,SAAS;AAC1B;AACA;AACA,gBAAgB,SAAS;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,mDAAG,SAAS,uDAAW;AAC3C;AACA;AACA;AACA,oBAAoB,mDAAG,SAAS,sDAAU;AAC1C;AACA;AACA,gBAAgB,oDAAI,SAAS,sDAAU;AACvC,gBAAgB,oDAAI,SAAS,uDAAW;AACxC;AACA,SAAS;AACT,YAAY,0DAAU;AACtB;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,iBAAiB,cAAc;AAC/B;AACA;AACA,gBAAgB,gBAAgB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,uBAAuB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,iBAAiB,cAAc;AAC/B;AACA;AACA,iCAAiC,wDAAQ,OAAO,wDAAQ;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,iBAAiB,cAAc;AAC/B;AACA;AACA,iCAAiC,wDAAQ,OAAO,wDAAQ;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR,QAAQ;AACR,eAAe,eAAe;AAC9B,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,iBAAiB,cAAc;AAC/B;AACA;AACA;AACA,2BAA2B,+DAAe;AAC1C;AACA;AACA;AACA,gBAAgB,wDAAQ,OAAO,wDAAQ;AACvC;AACA,wBAAwB,gBAAgB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,iBAAiB,cAAc;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,wDAAQ,OAAO,wDAAQ;AACnC;AACA,oBAAoB,gBAAgB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR,QAAQ;AACR,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,iBAAiB,cAAc;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR,QAAQ;AACR,eAAe,eAAe;AAC9B,eAAe,eAAe;AAC9B,iBAAiB,cAAc;AAC/B;AACA;AACA;AACA,4BAA4B,+DAAe;AAC3C,4BAA4B,+DAAe;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR,QAAQ;AACR,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,iBAAiB,cAAc;AAC/B;AACA;AACA,iCAAiC,wDAAQ,OAAO,wDAAQ;AACxD;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR,QAAQ;AACR,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,iBAAiB,cAAc;AAC/B;AACA;AACA,YAAY,wDAAQ;AACpB,eAAe,wDAAQ;AACvB,eAAe,wDAAQ;AACvB,eAAe,wDAAQ;AACvB,eAAe,wDAAQ;AACvB,eAAe,wDAAQ;AACvB,sCAAsC,gEAAgB;AACtD;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR,eAAe,cAAc;AAC7B,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,iBAAiB,cAAc;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,wDAAQ;AACxB,mBAAmB,wDAAQ;AAC3B,mBAAmB,wDAAQ;AAC3B,mBAAmB,wDAAQ;AAC3B,mBAAmB,wDAAQ;AAC3B,mBAAmB,wDAAQ;AAC3B;AACA;AACA,+BAA+B,2DAAe;AAC9C;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,iDAAiD,qBAAqB;AACtE;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR,iBAAiB,cAAc;AAC/B;AACA;AACA;AACA;AACA;AACA,qBAAqB,yDAAa;AAClC;;AAEmC;;;;;;;;;;;;;;ACtiBW;AACkI;;AAEhL,mBAAmB,cAAc,SAAS,OAAO,qCAAqC,kBAAkB,MAAM,QAAQ,qBAAqB,0BAA0B;;AAErK;AACA,2BAA2B,wDAAc;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,0DAAc;AACtE;AACA;AACA;AACA,wEAAwE,6DAAiB;AACzF;AACA;AACA,qEAAqE,yDAAa;AAClF;AACA;AACA;AACA;AACA,qEAAqE,yDAAa;AAClF;AACA;AACA;AACA;AACA,4BAA4B,uBAAuB;AACnD;AACA;AACA;AACA;AACA;AACA,gBAAgB,kDAAE,UAAU,8DAAkB;AAC9C,gBAAgB,kDAAE,UAAU,4DAAgB;AAC5C,gBAAgB,kDAAE,UAAU,wDAAY;AACxC;AACA;AACA;AACA;AACA;AACA,gBAAgB,UAAU;AAC1B;AACA;AACA,gBAAgB,mDAAG,UAAU,8DAAkB;AAC/C;AACA;AACA;AACA,gBAAgB,mDAAG,UAAU,4DAAgB;AAC7C;AACA;AACA;AACA,gBAAgB,mDAAG,UAAU,wDAAY;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,iBAAiB,cAAc;AAC/B;AACA;AACA,aAAa,wDAAQ;AACrB,gBAAgB,wDAAQ;AACxB,gBAAgB,wDAAQ;AACxB,gBAAgB,wDAAQ;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,cAAc;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,cAAc;AAC/B;AACA;AACA;AACA,oCAAoC,OAAO,MAAM,OAAO;AACxD;AACA;AACA,0BAA0B,kDAAM;AAChC,SAAS;AACT;AACA;AACA,qBAAqB,yDAAa;AAClC;;AAEmC;;;;;;;;;;;;;;ACpIW;AACe;;AAE7D,mBAAmB,oCAAoC,cAAc,4CAA4C,YAAY,OAAO,kBAAkB,MAAM,WAAW,qBAAqB,YAAY,uBAAuB,iBAAiB,yBAAyB,6BAA6B,YAAY,kBAAkB,WAAW,+BAA+B,oCAAoC,WAAW,cAAc,WAAW,SAAS,kBAAkB,QAAQ,+BAA+B,UAAU,kDAAkD,iBAAiB,SAAS,2BAA2B,WAAW,yBAAyB,SAAS,yBAAyB,YAAY,kDAAkD,iBAAiB,YAAY,QAAQ,2BAA2B,yBAAyB,WAAW,yBAAyB,UAAU,0BAA0B,mBAAmB,WAAW,SAAS,0BAA0B,mBAAmB,UAAU,SAAS,0BAA0B,YAAY,mBAAmB,WAAW,gCAAgC,YAAY,WAAW,wBAAwB,gCAAgC,YAAY,YAAY,sBAAsB,gCAAgC,WAAW,WAAW,0BAA0B,YAAY,mBAAmB,UAAU,eAAe,6BAA6B;;AAE33C,4BAA4B,wDAAc;AAC1C;AACA;AACA;AACA;AACA;AACA,sBAAsB,uDAAW;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,0DAAc;AACpC;;AAEoC;;;;;;;;;;;;;;AC1BU;AACkb;;AAEhe,mBAAmB,cAAc,OAAO,kBAAkB,QAAQ,kBAAkB,qCAAqC,kBAAkB,sCAAsC,wBAAwB,SAAS,WAAW,eAAe,cAAc,OAAO,kBAAkB,QAAQ,MAAM,0BAA0B,iCAAiC,UAAU,oBAAoB,kBAAkB,4BAA4B,mBAAmB,gCAAgC,aAAa;;AAExe;AACA,+BAA+B,wDAAc;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,wBAAwB,gEAAgB;AACxC;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,kDAAE,qBAAqB,yDAAa;AACpE;AACA;AACA;AACA,4BAA4B,mDAAG,qBAAqB,yDAAa;AACjE;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA,uCAAuC,wDAAY;AACnD;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,0DAAc;AACtE;AACA;AACA;AACA;AACA,wCAAwC,OAAO,MAAM,OAAO;AAC5D,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,kDAAE,UAAU,8DAAkB;AAC1C,YAAY,kDAAE,UAAU,4DAAgB;AACxC,YAAY,kDAAE,UAAU,wDAAY;AACpC;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,UAAU;AAC1B;AACA;AACA,gBAAgB,mDAAG,UAAU,8DAAkB;AAC/C;AACA;AACA;AACA,gBAAgB,mDAAG,UAAU,4DAAgB;AAC7C;AACA;AACA;AACA,gBAAgB,mDAAG,UAAU,wDAAY;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2FAA2F,6DAAiB;AAC5G;AACA;AACA;AACA;AACA,gBAAgB,iCAAiC;AACjD,YAAY,gEAAgB;AAC5B;AACA;AACA;AACA,gBAAgB,gEAAgB;AAChC,mBAAmB,gBAAgB,EAAE,gEAAgB,GAAG,4BAA4B;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,wDAAY;AACtD;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,uBAAuB,wDAAY;AACnC;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,gBAAgB,wBAAwB;AACxC;AACA;AACA;AACA,gBAAgB,eAAe;AAC/B,cAAc,SAAS;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,yDAAa;AACvD,4DAA4D,wDAAY;AACxE;AACA;AACA;AACA;AACA,gBAAgB,gBAAgB;AAChC,cAAc,cAAc;AAC5B;AACA,aAAa,gEAAgB;AAC7B,0BAA0B,gEAAgB,WAAW,gEAAgB;AACrE;AACA;AACA,iBAAiB,yDAAa;AAC9B;AACA,4BAA4B,UAAU;AACtC,mCAAmC,yDAAS;AAC5C;AACA;AACA;AACA;AACA,qCAAqC,mEAAuB;AAC5D;AACA;AACA;AACA,qCAAqC,mEAAuB;AAC5D;AACA;AACA;AACA;AACA;AACA,qCAAqC,mEAAuB;AAC5D;AACA;AACA;AACA,qCAAqC,mEAAuB;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,uDAAW;AAC5B;AACA;AACA;AACA;AACA;AACA,iBAAiB,wDAAY;AAC7B;AACA;AACA,mCAAmC,yDAAS;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,gBAAgB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,kBAAkB;AACnC;AACA;AACA,gBAAgB,gBAAgB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,iBAAiB,kBAAkB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,iBAAiB,kBAAkB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,iBAAiB,kBAAkB;AACnC;AACA;AACA;AACA;AACA;AACA,oCAAoC,gEAAgB;AACpD,gBAAgB,UAAU;AAC1B,cAAc,uBAAuB;AACrC;AACA,iBAAiB,+DAAmB;AACpC;AACA;AACA;AACA,6BAA6B,+DAAmB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,8DAAkB;AACnC;AACA;AACA,6BAA6B,8DAAkB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,+DAAmB;AACpC;AACA;AACA,6BAA6B,+DAAmB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,8DAAkB;AACnC;AACA;AACA;AACA,6BAA6B,8DAAkB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,mEAAuB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,mEAAuB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,mEAAuB;AACpD;AACA;AACA;AACA;AACA,6BAA6B,mEAAuB;AACpD;AACA;AACA;AACA;AACA,iBAAiB,mEAAuB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,mEAAuB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,mEAAuB;AACpD;AACA;AACA;AACA;AACA,6BAA6B,mEAAuB;AACpD;AACA;AACA;AACA;AACA,iBAAiB,mEAAuB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,mEAAuB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,mEAAuB;AACpD;AACA;AACA;AACA;AACA,6BAA6B,mEAAuB;AACpD;AACA;AACA;AACA;AACA,iBAAiB,mEAAuB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,mEAAuB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,mEAAuB;AACpD;AACA;AACA;AACA;AACA,6BAA6B,mEAAuB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,iBAAiB,kBAAkB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,gBAAgB;AAChC;AACA;AACA;AACA;AACA,YAAY,wDAAQ,OAAO,wDAAQ;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,iBAAiB,kBAAkB;AACnC;AACA;AACA;AACA,gBAAgB,wDAAQ;AACxB,gBAAgB,wDAAQ;AACxB,gBAAgB,wDAAQ;AACxB,gBAAgB,wDAAQ;AACxB;AACA;AACA;AACA;AACA,YAAY,gEAAgB;AAC5B,eAAe,gBAAgB,EAAE,gEAAgB,GAAG,4BAA4B;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,wDAAY;AACnC;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,kBAAkB;AACnC;AACA;AACA,gBAAgB,uBAAuB;AACvC;AACA;AACA;AACA;AACA,iBAAiB,kBAAkB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,kBAAkB;AACnC;AACA;AACA;AACA,oCAAoC,OAAO,MAAM,OAAO;AACxD;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,UAAU;AACzB,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,gBAAgB;AAClC;AACA,gBAAgB,6DAAa;AAC7B,oBAAoB,gEAAgB,mBAAmB,gEAAgB;AACvE,mBAAmB,gBAAgB,EAAE,gEAAgB;AACrD;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+EAA+E,yDAAa;AAC5F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,6DAAa,aAAa,0DAAU;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA,yBAAyB,6DAAiB;AAC1C;;AAEuC;;;;;;;;;;;;;;ACn0BO;AACA;;AAE9C,mBAAmB,aAAa,sBAAsB,kBAAkB,kBAAkB,yBAAyB,sBAAsB,iBAAiB,kBAAkB,qCAAqC,iBAAiB,SAAS,OAAO,kBAAkB,QAAQ,MAAM,WAAW,aAAa,OAAO,gBAAgB,yCAAyC,gBAAgB,OAAO,qBAAqB,0CAA0C;;AAEhc,0BAA0B,wDAAc;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,eAAe;AACvC;AACA;AACA,4BAA4B,kBAAkB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,wDAAY;AAChC;;AAEkC;;;;;;;;;;;;;;AC7DY;AACK;;AAEnD,mBAAmB,qBAAqB,WAAW,kBAAkB,kBAAkB,yBAAyB,sBAAsB,iBAAiB,sBAAsB,UAAU,yBAAyB,oCAAoC,WAAW,cAAc,kBAAkB,aAAa,WAAW,OAAO,QAAQ,2BAA2B,WAAW,YAAY,YAAY,SAAS,MAAM,2BAA2B,UAAU,kBAAkB,SAAS,kBAAkB,QAAQ,+BAA+B;;AAE5gB,+BAA+B,wDAAc;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,6DAAiB;AAC1C;;AAEuC;;;;;;;;;;;;;;;;;;ACtBO;AACmH;;AAEjK,mBAAmB,cAAc,YAAY,gBAAgB,kBAAkB,WAAW;;AAE1F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,wDAAc;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,6DAAiB;AAC1E;AACA,YAAY,yDAAS;AACrB;AACA;AACA,YAAY,kDAAE,aAAa,wDAAY;AACvC,kEAAkE,0DAAc;AAChF;AACA;AACA,8EAA8E,yDAAa;AAC3F;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,kDAAE,sBAAsB,sDAAU;AACtD,oBAAoB,kDAAE,eAAe,2DAAe;AACpD;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,2BAA2B;AAC3C;AACA,YAAY,mDAAG,aAAa,wDAAY;AACxC;AACA;AACA;AACA,YAAY,mDAAG,sBAAsB,sDAAU;AAC/C;AACA;AACA;AACA,YAAY,mDAAG,eAAe,2DAAe;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,uBAAuB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,sBAAsB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,uBAAuB;AACvC;AACA,gBAAgB,4BAA4B;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,gCAAgC;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA,sBAAsB,0DAAc;AACpC;;AAEkG;;;;;;;UCpMlG;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;WCtBA;WACA;WACA;WACA;WACA,yCAAyC,wCAAwC;WACjF;WACA;WACA;;;;;WCPA;;;;;WCAA;WACA;WACA;WACA,uDAAuD,iBAAiB;WACxE;WACA,gDAAgD,aAAa;WAC7D;;;;;;;;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEgC;AAChC,iBAAiB,iDAAO","sources":["webpack://@glpi/glpi/./node_modules/cropperjs/dist/cropper.esm.raw.js","webpack://@glpi/glpi/./node_modules/@cropper/utils/dist/utils.esm.raw.js","webpack://@glpi/glpi/./node_modules/@cropper/elements/dist/elements.esm.raw.js","webpack://@glpi/glpi/./node_modules/@cropper/element/dist/element.esm.raw.js","webpack://@glpi/glpi/./node_modules/@cropper/element-canvas/dist/element-canvas.esm.raw.js","webpack://@glpi/glpi/./node_modules/@cropper/element-image/dist/element-image.esm.raw.js","webpack://@glpi/glpi/./node_modules/@cropper/element-shade/dist/element-shade.esm.raw.js","webpack://@glpi/glpi/./node_modules/@cropper/element-handle/dist/element-handle.esm.raw.js","webpack://@glpi/glpi/./node_modules/@cropper/element-selection/dist/element-selection.esm.raw.js","webpack://@glpi/glpi/./node_modules/@cropper/element-grid/dist/element-grid.esm.raw.js","webpack://@glpi/glpi/./node_modules/@cropper/element-crosshair/dist/element-crosshair.esm.raw.js","webpack://@glpi/glpi/./node_modules/@cropper/element-viewer/dist/element-viewer.esm.raw.js","webpack://@glpi/glpi/webpack/bootstrap","webpack://@glpi/glpi/webpack/runtime/define property getters","webpack://@glpi/glpi/webpack/runtime/hasOwnProperty shorthand","webpack://@glpi/glpi/webpack/runtime/make namespace object","webpack://@glpi/glpi/./lib/bundles/cropper.js"],"sourcesContent":["/*! Cropper.js v2.0.0 | (c) 2015-present Chen Fengyuan | MIT */\nimport { isString, isElement, CROPPER_IMAGE, CROPPER_CANVAS, CROPPER_SELECTION } from '@cropper/utils';\nexport * from '@cropper/utils';\nimport { CropperCanvas, CropperCrosshair, CropperGrid, CropperHandle, CropperImage, CropperSelection, CropperShade, CropperViewer } from '@cropper/elements';\nexport * from '@cropper/elements';\n\nvar DEFAULT_TEMPLATE = ('<cropper-canvas background>'\n    + '<cropper-image rotatable scalable skewable translatable></cropper-image>'\n    + '<cropper-shade hidden></cropper-shade>'\n    + '<cropper-handle action=\"select\" plain></cropper-handle>'\n    + '<cropper-selection initial-coverage=\"0.5\" movable resizable>'\n    + '<cropper-grid role=\"grid\" bordered covered></cropper-grid>'\n    + '<cropper-crosshair centered></cropper-crosshair>'\n    + '<cropper-handle action=\"move\" theme-color=\"rgba(255, 255, 255, 0.35)\"></cropper-handle>'\n    + '<cropper-handle action=\"n-resize\"></cropper-handle>'\n    + '<cropper-handle action=\"e-resize\"></cropper-handle>'\n    + '<cropper-handle action=\"s-resize\"></cropper-handle>'\n    + '<cropper-handle action=\"w-resize\"></cropper-handle>'\n    + '<cropper-handle action=\"ne-resize\"></cropper-handle>'\n    + '<cropper-handle action=\"nw-resize\"></cropper-handle>'\n    + '<cropper-handle action=\"se-resize\"></cropper-handle>'\n    + '<cropper-handle action=\"sw-resize\"></cropper-handle>'\n    + '</cropper-selection>'\n    + '</cropper-canvas>');\n\nconst REGEXP_ALLOWED_ELEMENTS = /^img|canvas$/;\nconst REGEXP_BLOCKED_TAGS = /<(\\/?(?:script|style)[^>]*)>/gi;\nconst DEFAULT_OPTIONS = {\n    template: DEFAULT_TEMPLATE,\n};\nCropperCanvas.$define();\nCropperCrosshair.$define();\nCropperGrid.$define();\nCropperHandle.$define();\nCropperImage.$define();\nCropperSelection.$define();\nCropperShade.$define();\nCropperViewer.$define();\nclass Cropper {\n    constructor(element, options) {\n        this.options = DEFAULT_OPTIONS;\n        if (isString(element)) {\n            element = document.querySelector(element);\n        }\n        if (!isElement(element) || !REGEXP_ALLOWED_ELEMENTS.test(element.localName)) {\n            throw new Error('The first argument is required and must be an <img> or <canvas> element.');\n        }\n        this.element = element;\n        options = Object.assign(Object.assign({}, DEFAULT_OPTIONS), options);\n        this.options = options;\n        const { ownerDocument } = element;\n        let { container } = options;\n        if (container) {\n            if (isString(container)) {\n                container = ownerDocument.querySelector(container);\n            }\n            if (!isElement(container)) {\n                throw new Error('The `container` option must be an element or a valid selector.');\n            }\n        }\n        if (!isElement(container)) {\n            if (element.parentElement) {\n                container = element.parentElement;\n            }\n            else {\n                container = ownerDocument.body;\n            }\n        }\n        this.container = container;\n        const tagName = element.localName;\n        let src = '';\n        if (tagName === 'img') {\n            ({ src } = element);\n        }\n        else if (tagName === 'canvas' && window.HTMLCanvasElement) {\n            src = element.toDataURL();\n        }\n        const { template } = options;\n        if (template && isString(template)) {\n            const templateElement = document.createElement('template');\n            const documentFragment = document.createDocumentFragment();\n            templateElement.innerHTML = template.replace(REGEXP_BLOCKED_TAGS, '&lt;$1&gt;');\n            documentFragment.appendChild(templateElement.content);\n            Array.from(documentFragment.querySelectorAll(CROPPER_IMAGE)).forEach((image) => {\n                image.setAttribute('src', src);\n                image.setAttribute('alt', element.alt || 'The image to crop');\n            });\n            if (element.parentElement) {\n                element.style.display = 'none';\n                container.insertBefore(documentFragment, element.nextSibling);\n            }\n            else {\n                container.appendChild(documentFragment);\n            }\n        }\n    }\n    getCropperCanvas() {\n        return this.container.querySelector(CROPPER_CANVAS);\n    }\n    getCropperImage() {\n        return this.container.querySelector(CROPPER_IMAGE);\n    }\n    getCropperSelection() {\n        return this.container.querySelector(CROPPER_SELECTION);\n    }\n    getCropperSelections() {\n        return this.container.querySelectorAll(CROPPER_SELECTION);\n    }\n}\nCropper.version = '2.0.0';\n\nexport { DEFAULT_TEMPLATE, Cropper as default };\n","const IS_BROWSER = typeof window !== 'undefined' && typeof window.document !== 'undefined';\nconst WINDOW = IS_BROWSER ? window : {};\nconst IS_TOUCH_DEVICE = IS_BROWSER ? 'ontouchstart' in WINDOW.document.documentElement : false;\nconst HAS_POINTER_EVENT = IS_BROWSER ? 'PointerEvent' in WINDOW : false;\nconst NAMESPACE = 'cropper';\nconst CROPPER_CANVAS = `${NAMESPACE}-canvas`;\nconst CROPPER_CROSSHAIR = `${NAMESPACE}-crosshair`;\nconst CROPPER_GIRD = `${NAMESPACE}-grid`;\nconst CROPPER_HANDLE = `${NAMESPACE}-handle`;\nconst CROPPER_IMAGE = `${NAMESPACE}-image`;\nconst CROPPER_SELECTION = `${NAMESPACE}-selection`;\nconst CROPPER_SHADE = `${NAMESPACE}-shade`;\nconst CROPPER_VIEWER = `${NAMESPACE}-viewer`;\n// Actions\nconst ACTION_SELECT = 'select';\nconst ACTION_MOVE = 'move';\nconst ACTION_SCALE = 'scale';\nconst ACTION_ROTATE = 'rotate';\nconst ACTION_TRANSFORM = 'transform';\nconst ACTION_NONE = 'none';\nconst ACTION_RESIZE_NORTH = 'n-resize';\nconst ACTION_RESIZE_EAST = 'e-resize';\nconst ACTION_RESIZE_SOUTH = 's-resize';\nconst ACTION_RESIZE_WEST = 'w-resize';\nconst ACTION_RESIZE_NORTHEAST = 'ne-resize';\nconst ACTION_RESIZE_NORTHWEST = 'nw-resize';\nconst ACTION_RESIZE_SOUTHEAST = 'se-resize';\nconst ACTION_RESIZE_SOUTHWEST = 'sw-resize';\n// Attributes\nconst ATTRIBUTE_ACTION = 'action';\n// Native events\nconst EVENT_TOUCH_END = IS_TOUCH_DEVICE ? 'touchend touchcancel' : 'mouseup';\nconst EVENT_TOUCH_MOVE = IS_TOUCH_DEVICE ? 'touchmove' : 'mousemove';\nconst EVENT_TOUCH_START = IS_TOUCH_DEVICE ? 'touchstart' : 'mousedown';\nconst EVENT_POINTER_DOWN = HAS_POINTER_EVENT ? 'pointerdown' : EVENT_TOUCH_START;\nconst EVENT_POINTER_MOVE = HAS_POINTER_EVENT ? 'pointermove' : EVENT_TOUCH_MOVE;\nconst EVENT_POINTER_UP = HAS_POINTER_EVENT ? 'pointerup pointercancel' : EVENT_TOUCH_END;\nconst EVENT_ERROR = 'error';\nconst EVENT_KEYDOWN = 'keydown';\nconst EVENT_LOAD = 'load';\nconst EVENT_RESIZE = 'resize';\nconst EVENT_WHEEL = 'wheel';\n// Custom events\nconst EVENT_ACTION = 'action';\nconst EVENT_ACTION_END = 'actionend';\nconst EVENT_ACTION_MOVE = 'actionmove';\nconst EVENT_ACTION_START = 'actionstart';\nconst EVENT_CHANGE = 'change';\nconst EVENT_TRANSFORM = 'transform';\n\n/**\n * Check if the given value is a string.\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if the given value is a string, else `false`.\n */\nfunction isString(value) {\n    return typeof value === 'string';\n}\n/**\n * Check if the given value is not a number.\n */\nconst isNaN = Number.isNaN || WINDOW.isNaN;\n/**\n * Check if the given value is a number.\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if the given value is a number, else `false`.\n */\nfunction isNumber(value) {\n    return typeof value === 'number' && !isNaN(value);\n}\n/**\n * Check if the given value is a positive number.\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if the given value is a positive number, else `false`.\n */\nfunction isPositiveNumber(value) {\n    return isNumber(value) && value > 0 && value < Infinity;\n}\n/**\n * Check if the given value is undefined.\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if the given value is undefined, else `false`.\n */\nfunction isUndefined(value) {\n    return typeof value === 'undefined';\n}\n/**\n * Check if the given value is an object.\n * @param {*} value - The value to check.\n * @returns {boolean} Returns `true` if the given value is an object, else `false`.\n */\nfunction isObject(value) {\n    return typeof value === 'object' && value !== null;\n}\nconst { hasOwnProperty } = Object.prototype;\n/**\n * Check if the given value is a plain object.\n * @param {*} value - The value to check.\n * @returns {boolean} Returns `true` if the given value is a plain object, else `false`.\n */\nfunction isPlainObject(value) {\n    if (!isObject(value)) {\n        return false;\n    }\n    try {\n        const { constructor } = value;\n        const { prototype } = constructor;\n        return constructor && prototype && hasOwnProperty.call(prototype, 'isPrototypeOf');\n    }\n    catch (error) {\n        return false;\n    }\n}\n/**\n * Check if the given value is a function.\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if the given value is a function, else `false`.\n */\nfunction isFunction(value) {\n    return typeof value === 'function';\n}\n/**\n * Check if the given node is an element.\n * @param {*} node The node to check.\n * @returns {boolean} Returns `true` if the given node is an element; otherwise, `false`.\n */\nfunction isElement(node) {\n    return typeof node === 'object' && node !== null && node.nodeType === 1;\n}\nconst REGEXP_CAMEL_CASE = /([a-z\\d])([A-Z])/g;\n/**\n * Transform the given string from camelCase to kebab-case.\n * @param {string} value The value to transform.\n * @returns {string} Returns the transformed value.\n */\nfunction toKebabCase(value) {\n    return String(value).replace(REGEXP_CAMEL_CASE, '$1-$2').toLowerCase();\n}\nconst REGEXP_KEBAB_CASE = /-[A-z\\d]/g;\n/**\n * Transform the given string from kebab-case to camelCase.\n * @param {string} value The value to transform.\n * @returns {string} Returns the transformed value.\n */\nfunction toCamelCase(value) {\n    return value.replace(REGEXP_KEBAB_CASE, (substring) => substring.slice(1).toUpperCase());\n}\nconst REGEXP_SPACES = /\\s\\s*/;\n/**\n * Remove event listener from the event target.\n * {@link https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/removeEventListener}\n * @param {EventTarget} target The target of the event.\n * @param {string} types The types of the event.\n * @param {EventListenerOrEventListenerObject} listener The listener of the event.\n * @param {EventListenerOptions} [options] The options specify characteristics about the event listener.\n */\nfunction off(target, types, listener, options) {\n    types.trim().split(REGEXP_SPACES).forEach((type) => {\n        target.removeEventListener(type, listener, options);\n    });\n}\n/**\n * Add event listener to the event target.\n * {@link https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener}\n * @param {EventTarget} target The target of the event.\n * @param {string} types The types of the event.\n * @param {EventListenerOrEventListenerObject} listener The listener of the event.\n * @param {AddEventListenerOptions} [options] The options specify characteristics about the event listener.\n */\nfunction on(target, types, listener, options) {\n    types.trim().split(REGEXP_SPACES).forEach((type) => {\n        target.addEventListener(type, listener, options);\n    });\n}\n/**\n * Add once event listener to the event target.\n * @param {EventTarget} target The target of the event.\n * @param {string} types The types of the event.\n * @param {EventListenerOrEventListenerObject} listener The listener of the event.\n * @param {AddEventListenerOptions} [options] The options specify characteristics about the event listener.\n */\nfunction once(target, types, listener, options) {\n    on(target, types, listener, Object.assign(Object.assign({}, options), { once: true }));\n}\nconst defaultEventOptions = {\n    bubbles: true,\n    cancelable: true,\n    composed: true,\n};\n/**\n * Dispatch event on the event target.\n * {@link https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/dispatchEvent}\n * @param {EventTarget} target The target of the event.\n * @param {string} type The name of the event.\n * @param {*} [detail] The data passed when initializing the event.\n * @param {CustomEventInit} [options] The other event options.\n * @returns {boolean} Returns the result value.\n */\nfunction emit(target, type, detail, options) {\n    return target.dispatchEvent(new CustomEvent(type, Object.assign(Object.assign(Object.assign({}, defaultEventOptions), { detail }), options)));\n}\nconst resolvedPromise = Promise.resolve();\n/**\n * Defers the callback to be executed after the next DOM update cycle.\n * @param {*} [context] The `this` context.\n * @param {Function} [callback] The callback to execute after the next DOM update cycle.\n * @returns {Promise} A promise that resolves to nothing.\n */\nfunction nextTick(context, callback) {\n    return callback\n        ? resolvedPromise.then(context ? callback.bind(context) : callback)\n        : resolvedPromise;\n}\n/**\n * Get the offset base on the document.\n * @param {Element} element The target element.\n * @returns {object} The offset data.\n */\nfunction getOffset(element) {\n    const { documentElement } = element.ownerDocument;\n    const box = element.getBoundingClientRect();\n    return {\n        left: box.left + (WINDOW.pageXOffset - documentElement.clientLeft),\n        top: box.top + (WINDOW.pageYOffset - documentElement.clientTop),\n    };\n}\nconst REGEXP_ANGLE_UNIT = /deg|g?rad|turn$/i;\n/**\n * Convert an angle to a radian number.\n * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/angle}\n * @param {number|string} angle The angle to convert.\n * @returns {number} Returns the radian number.\n */\nfunction toAngleInRadian(angle) {\n    const value = parseFloat(angle) || 0;\n    if (value !== 0) {\n        const [unit = 'rad'] = String(angle).match(REGEXP_ANGLE_UNIT) || [];\n        switch (unit.toLowerCase()) {\n            case 'deg':\n                return (value / 360) * (Math.PI * 2);\n            case 'grad':\n                return (value / 400) * (Math.PI * 2);\n            case 'turn':\n                return value * (Math.PI * 2);\n        }\n    }\n    return value;\n}\nconst SIZE_ADJUSTMENT_TYPE_CONTAIN = 'contain';\nconst SIZE_ADJUSTMENT_TYPE_COVER = 'cover';\n/**\n * Get the max sizes in a rectangle under the given aspect ratio.\n * @param {object} data The original sizes.\n * @param {string} [type] The adjust type.\n * @returns {object} Returns the result sizes.\n */\nfunction getAdjustedSizes(data, type = SIZE_ADJUSTMENT_TYPE_CONTAIN) {\n    const { aspectRatio } = data;\n    let { width, height } = data;\n    const isValidWidth = isPositiveNumber(width);\n    const isValidHeight = isPositiveNumber(height);\n    if (isValidWidth && isValidHeight) {\n        const adjustedWidth = height * aspectRatio;\n        if ((type === SIZE_ADJUSTMENT_TYPE_CONTAIN && adjustedWidth > width)\n            || (type === SIZE_ADJUSTMENT_TYPE_COVER && adjustedWidth < width)) {\n            height = width / aspectRatio;\n        }\n        else {\n            width = height * aspectRatio;\n        }\n    }\n    else if (isValidWidth) {\n        height = width / aspectRatio;\n    }\n    else if (isValidHeight) {\n        width = height * aspectRatio;\n    }\n    return {\n        width,\n        height,\n    };\n}\n/**\n * Multiply multiple matrices.\n * @param {Array} matrix The first matrix.\n * @param {Array} args The rest matrices.\n * @returns {Array} Returns the result matrix.\n */\nfunction multiplyMatrices(matrix, ...args) {\n    if (args.length === 0) {\n        return matrix;\n    }\n    const [a1, b1, c1, d1, e1, f1] = matrix;\n    const [a2, b2, c2, d2, e2, f2] = args[0];\n    // ┌ a1 c1 e1 ┐   ┌ a2 c2 e2 ┐\n    // │ b1 d1 f1 │ × │ b2 d2 f2 │\n    // └ 0  0  1  ┘   └ 0  0  1  ┘\n    matrix = [\n        a1 * a2 + c1 * b2 /* + e1 * 0 */,\n        b1 * a2 + d1 * b2 /* + f1 * 0 */,\n        a1 * c2 + c1 * d2 /* + e1 * 0 */,\n        b1 * c2 + d1 * d2 /* + f1 * 0 */,\n        a1 * e2 + c1 * f2 + e1 /* * 1 */,\n        b1 * e2 + d1 * f2 + f1 /* * 1 */,\n    ];\n    return multiplyMatrices(matrix, ...args.slice(1));\n}\n\nexport { ACTION_MOVE, ACTION_NONE, ACTION_RESIZE_EAST, ACTION_RESIZE_NORTH, ACTION_RESIZE_NORTHEAST, ACTION_RESIZE_NORTHWEST, ACTION_RESIZE_SOUTH, ACTION_RESIZE_SOUTHEAST, ACTION_RESIZE_SOUTHWEST, ACTION_RESIZE_WEST, ACTION_ROTATE, ACTION_SCALE, ACTION_SELECT, ACTION_TRANSFORM, ATTRIBUTE_ACTION, CROPPER_CANVAS, CROPPER_CROSSHAIR, CROPPER_GIRD, CROPPER_HANDLE, CROPPER_IMAGE, CROPPER_SELECTION, CROPPER_SHADE, CROPPER_VIEWER, EVENT_ACTION, EVENT_ACTION_END, EVENT_ACTION_MOVE, EVENT_ACTION_START, EVENT_CHANGE, EVENT_ERROR, EVENT_KEYDOWN, EVENT_LOAD, EVENT_POINTER_DOWN, EVENT_POINTER_MOVE, EVENT_POINTER_UP, EVENT_RESIZE, EVENT_TOUCH_END, EVENT_TOUCH_MOVE, EVENT_TOUCH_START, EVENT_TRANSFORM, EVENT_WHEEL, HAS_POINTER_EVENT, IS_BROWSER, IS_TOUCH_DEVICE, NAMESPACE, WINDOW, emit, getAdjustedSizes, getOffset, isElement, isFunction, isNaN, isNumber, isObject, isPlainObject, isPositiveNumber, isString, isUndefined, multiplyMatrices, nextTick, off, on, once, toAngleInRadian, toCamelCase, toKebabCase };\n","export { default as CropperElement } from '@cropper/element';\nexport { default as CropperCanvas } from '@cropper/element-canvas';\nexport { default as CropperImage } from '@cropper/element-image';\nexport { default as CropperShade } from '@cropper/element-shade';\nexport { default as CropperHandle } from '@cropper/element-handle';\nexport { default as CropperSelection } from '@cropper/element-selection';\nexport { default as CropperGrid } from '@cropper/element-grid';\nexport { default as CropperCrosshair } from '@cropper/element-crosshair';\nexport { default as CropperViewer } from '@cropper/element-viewer';\n","import { WINDOW, toCamelCase, toKebabCase, isNaN, isUndefined, isNumber, emit, nextTick, isObject, IS_BROWSER } from '@cropper/utils';\n\nvar style = `:host([hidden]){display:none!important}`;\n\nconst REGEXP_SUFFIX = /left|top|width|height/i;\nconst DEFAULT_SHADOW_ROOT_MODE = 'open';\nconst shadowRoots = new WeakMap();\nconst styleSheets = new WeakMap();\nconst tagNames = new Map();\nconst supportsAdoptedStyleSheets = WINDOW.document && Array.isArray(WINDOW.document.adoptedStyleSheets) && 'replaceSync' in WINDOW.CSSStyleSheet.prototype;\nclass CropperElement extends HTMLElement {\n    get $sharedStyle() {\n        return `${this.themeColor ? `:host{--theme-color: ${this.themeColor};}` : ''}${style}`;\n    }\n    constructor() {\n        var _a, _b;\n        super();\n        this.shadowRootMode = DEFAULT_SHADOW_ROOT_MODE;\n        this.slottable = true;\n        const name = (_b = (_a = Object.getPrototypeOf(this)) === null || _a === void 0 ? void 0 : _a.constructor) === null || _b === void 0 ? void 0 : _b.$name;\n        if (name) {\n            tagNames.set(name, this.tagName.toLowerCase());\n        }\n    }\n    static get observedAttributes() {\n        return [\n            'shadow-root-mode',\n            'slottable',\n            'theme-color',\n        ];\n    }\n    // Convert attribute to property\n    attributeChangedCallback(name, oldValue, newValue) {\n        if (Object.is(newValue, oldValue)) {\n            return;\n        }\n        const propertyName = toCamelCase(name);\n        const oldPropertyValue = this[propertyName];\n        let newPropertyValue = newValue;\n        switch (typeof oldPropertyValue) {\n            case 'boolean':\n                newPropertyValue = newValue !== null && newValue !== 'false';\n                break;\n            case 'number':\n                newPropertyValue = Number(newValue);\n                break;\n        }\n        this[propertyName] = newPropertyValue;\n        switch (name) {\n            case 'theme-color': {\n                const styleSheet = styleSheets.get(this);\n                const styles = this.$sharedStyle;\n                if (styleSheet && styles) {\n                    if (supportsAdoptedStyleSheets) {\n                        styleSheet.replaceSync(styles);\n                    }\n                    else {\n                        styleSheet.textContent = styles;\n                    }\n                }\n                break;\n            }\n        }\n    }\n    // Convert property to attribute\n    $propertyChangedCallback(name, oldValue, newValue) {\n        if (Object.is(newValue, oldValue)) {\n            return;\n        }\n        name = toKebabCase(name);\n        switch (typeof newValue) {\n            case 'boolean':\n                if (newValue === true) {\n                    if (!this.hasAttribute(name)) {\n                        this.setAttribute(name, '');\n                    }\n                }\n                else {\n                    this.removeAttribute(name);\n                }\n                break;\n            case 'number':\n                if (isNaN(newValue)) {\n                    newValue = '';\n                }\n                else {\n                    newValue = String(newValue);\n                }\n            // Fall through\n            // case 'string':\n            // eslint-disable-next-line no-fallthrough\n            default:\n                if (newValue) {\n                    if (this.getAttribute(name) !== newValue) {\n                        this.setAttribute(name, newValue);\n                    }\n                }\n                else {\n                    this.removeAttribute(name);\n                }\n        }\n    }\n    connectedCallback() {\n        // Observe properties after observed attributes\n        Object.getPrototypeOf(this).constructor.observedAttributes.forEach((attribute) => {\n            const property = toCamelCase(attribute);\n            let value = this[property];\n            if (!isUndefined(value)) {\n                this.$propertyChangedCallback(property, undefined, value);\n            }\n            Object.defineProperty(this, property, {\n                enumerable: true,\n                configurable: true,\n                get() {\n                    return value;\n                },\n                set(newValue) {\n                    const oldValue = value;\n                    value = newValue;\n                    this.$propertyChangedCallback(property, oldValue, newValue);\n                },\n            });\n        });\n        const shadow = this.attachShadow({\n            mode: this.shadowRootMode || DEFAULT_SHADOW_ROOT_MODE,\n        });\n        if (!this.shadowRoot) {\n            shadowRoots.set(this, shadow);\n        }\n        styleSheets.set(this, this.$addStyles(this.$sharedStyle));\n        if (this.$style) {\n            this.$addStyles(this.$style);\n        }\n        if (this.$template) {\n            const template = document.createElement('template');\n            template.innerHTML = this.$template;\n            shadow.appendChild(template.content);\n        }\n        if (this.slottable) {\n            const slot = document.createElement('slot');\n            shadow.appendChild(slot);\n        }\n    }\n    disconnectedCallback() {\n        if (styleSheets.has(this)) {\n            styleSheets.delete(this);\n        }\n        if (shadowRoots.has(this)) {\n            shadowRoots.delete(this);\n        }\n    }\n    // eslint-disable-next-line class-methods-use-this\n    $getTagNameOf(name) {\n        var _a;\n        return (_a = tagNames.get(name)) !== null && _a !== void 0 ? _a : name;\n    }\n    $setStyles(properties) {\n        Object.keys(properties).forEach((property) => {\n            let value = properties[property];\n            if (isNumber(value)) {\n                if (value !== 0 && REGEXP_SUFFIX.test(property)) {\n                    value = `${value}px`;\n                }\n                else {\n                    value = String(value);\n                }\n            }\n            this.style[property] = value;\n        });\n        return this;\n    }\n    /**\n     * Outputs the shadow root of the element.\n     * @returns {ShadowRoot} Returns the shadow root.\n     */\n    $getShadowRoot() {\n        return this.shadowRoot || shadowRoots.get(this);\n    }\n    /**\n     * Adds styles to the shadow root.\n     * @param {string} styles The styles to add.\n     * @returns {CSSStyleSheet|HTMLStyleElement} Returns the generated style sheet.\n     */\n    $addStyles(styles) {\n        let styleSheet;\n        const shadow = this.$getShadowRoot();\n        if (supportsAdoptedStyleSheets) {\n            styleSheet = new CSSStyleSheet();\n            styleSheet.replaceSync(styles);\n            shadow.adoptedStyleSheets = shadow.adoptedStyleSheets.concat(styleSheet);\n        }\n        else {\n            styleSheet = document.createElement('style');\n            styleSheet.textContent = styles;\n            shadow.appendChild(styleSheet);\n        }\n        return styleSheet;\n    }\n    /**\n     * Dispatches an event at the element.\n     * @param {string} type The name of the event.\n     * @param {*} [detail] The data passed when initializing the event.\n     * @param {CustomEventInit} [options] The other event options.\n     * @returns {boolean} Returns the result value.\n     */\n    $emit(type, detail, options) {\n        return emit(this, type, detail, options);\n    }\n    /**\n     * Defers the callback to be executed after the next DOM update cycle.\n     * @param {Function} [callback] The callback to execute after the next DOM update cycle.\n     * @returns {Promise} A promise that resolves to nothing.\n     */\n    $nextTick(callback) {\n        return nextTick(this, callback);\n    }\n    /**\n     * Defines the constructor as a new custom element.\n     * {@link https://developer.mozilla.org/en-US/docs/Web/API/CustomElementRegistry/define}\n     * @param {string|object} [name] The element name.\n     * @param {object} [options] The element definition options.\n     */\n    static $define(name, options) {\n        if (isObject(name)) {\n            options = name;\n            name = '';\n        }\n        if (!name) {\n            name = this.$name || this.name;\n        }\n        name = toKebabCase(name);\n        if (IS_BROWSER && WINDOW.customElements && !WINDOW.customElements.get(name)) {\n            customElements.define(name, this, options);\n        }\n    }\n}\nCropperElement.$version = '2.0.0';\n\nexport { CropperElement as default };\n","import CropperElement from '@cropper/element';\nimport { CROPPER_CANVAS, ACTION_NONE, on, EVENT_POINTER_DOWN, EVENT_POINTER_MOVE, EVENT_POINTER_UP, EVENT_WHEEL, off, isNumber, isElement, ATTRIBUTE_ACTION, EVENT_ACTION_START, EVENT_ACTION_MOVE, ACTION_TRANSFORM, EVENT_ACTION, EVENT_ACTION_END, ACTION_SCALE, isString, isPlainObject, isPositiveNumber, getAdjustedSizes, CROPPER_IMAGE, isFunction, ACTION_ROTATE } from '@cropper/utils';\n\nvar style = `:host{display:block;min-height:100px;min-width:200px;overflow:hidden;position:relative;touch-action:none;-webkit-touch-callout:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}:host([background]){background-color:#fff;background-image:repeating-linear-gradient(45deg,#ccc 25%,transparent 0,transparent 75%,#ccc 0,#ccc),repeating-linear-gradient(45deg,#ccc 25%,transparent 0,transparent 75%,#ccc 0,#ccc);background-image:repeating-conic-gradient(#ccc 0 25%,#fff 0 50%);background-position:0 0,.5rem .5rem;background-size:1rem 1rem}:host([disabled]){pointer-events:none}:host([disabled]):after{bottom:0;content:\"\";cursor:not-allowed;display:block;left:0;pointer-events:none;position:absolute;right:0;top:0}`;\n\nclass CropperCanvas extends CropperElement {\n    constructor() {\n        super(...arguments);\n        this.$onPointerDown = null;\n        this.$onPointerMove = null;\n        this.$onPointerUp = null;\n        this.$onWheel = null;\n        this.$wheeling = false;\n        this.$pointers = new Map();\n        this.$style = style;\n        this.$action = ACTION_NONE;\n        this.background = false;\n        this.disabled = false;\n        this.scaleStep = 0.1;\n        this.themeColor = '#39f';\n    }\n    static get observedAttributes() {\n        return super.observedAttributes.concat([\n            'background',\n            'disabled',\n            'scale-step',\n        ]);\n    }\n    connectedCallback() {\n        super.connectedCallback();\n        if (!this.disabled) {\n            this.$bind();\n        }\n    }\n    disconnectedCallback() {\n        if (!this.disabled) {\n            this.$unbind();\n        }\n        super.disconnectedCallback();\n    }\n    $propertyChangedCallback(name, oldValue, newValue) {\n        if (Object.is(newValue, oldValue)) {\n            return;\n        }\n        super.$propertyChangedCallback(name, oldValue, newValue);\n        switch (name) {\n            case 'disabled':\n                if (newValue) {\n                    this.$unbind();\n                }\n                else {\n                    this.$bind();\n                }\n                break;\n        }\n    }\n    $bind() {\n        if (!this.$onPointerDown) {\n            this.$onPointerDown = this.$handlePointerDown.bind(this);\n            on(this, EVENT_POINTER_DOWN, this.$onPointerDown);\n        }\n        if (!this.$onPointerMove) {\n            this.$onPointerMove = this.$handlePointerMove.bind(this);\n            on(this.ownerDocument, EVENT_POINTER_MOVE, this.$onPointerMove);\n        }\n        if (!this.$onPointerUp) {\n            this.$onPointerUp = this.$handlePointerUp.bind(this);\n            on(this.ownerDocument, EVENT_POINTER_UP, this.$onPointerUp);\n        }\n        if (!this.$onWheel) {\n            this.$onWheel = this.$handleWheel.bind(this);\n            on(this, EVENT_WHEEL, this.$onWheel, {\n                passive: false,\n                capture: true,\n            });\n        }\n    }\n    $unbind() {\n        if (this.$onPointerDown) {\n            off(this, EVENT_POINTER_DOWN, this.$onPointerDown);\n            this.$onPointerDown = null;\n        }\n        if (this.$onPointerMove) {\n            off(this.ownerDocument, EVENT_POINTER_MOVE, this.$onPointerMove);\n            this.$onPointerMove = null;\n        }\n        if (this.$onPointerUp) {\n            off(this.ownerDocument, EVENT_POINTER_UP, this.$onPointerUp);\n            this.$onPointerUp = null;\n        }\n        if (this.$onWheel) {\n            off(this, EVENT_WHEEL, this.$onWheel, {\n                capture: true,\n            });\n            this.$onWheel = null;\n        }\n    }\n    $handlePointerDown(event) {\n        const { buttons, button, type } = event;\n        if (this.disabled || (\n        // Handle pointer or mouse event, and ignore touch event\n        ((type === 'pointerdown' && event.pointerType === 'mouse') || type === 'mousedown') && (\n        // No primary button (Usually the left button)\n        (isNumber(buttons) && buttons !== 1) || (isNumber(button) && button !== 0)\n            // Open context menu\n            || event.ctrlKey))) {\n            return;\n        }\n        const { $pointers } = this;\n        let action = '';\n        if (event.changedTouches) {\n            Array.from(event.changedTouches).forEach(({ identifier, pageX, pageY, }) => {\n                $pointers.set(identifier, {\n                    startX: pageX,\n                    startY: pageY,\n                    endX: pageX,\n                    endY: pageY,\n                });\n            });\n        }\n        else {\n            const { pointerId = 0, pageX, pageY } = event;\n            $pointers.set(pointerId, {\n                startX: pageX,\n                startY: pageY,\n                endX: pageX,\n                endY: pageY,\n            });\n        }\n        if ($pointers.size > 1) {\n            action = ACTION_TRANSFORM;\n        }\n        else if (isElement(event.target)) {\n            action = event.target.action || event.target.getAttribute(ATTRIBUTE_ACTION) || '';\n        }\n        if (this.$emit(EVENT_ACTION_START, {\n            action,\n            relatedEvent: event,\n        }) === false) {\n            return;\n        }\n        // Prevent page zooming in the browsers for iOS.\n        event.preventDefault();\n        this.$action = action;\n        this.style.willChange = 'transform';\n    }\n    $handlePointerMove(event) {\n        const { $action, $pointers } = this;\n        if (this.disabled || $action === ACTION_NONE || $pointers.size === 0) {\n            return;\n        }\n        if (this.$emit(EVENT_ACTION_MOVE, {\n            action: $action,\n            relatedEvent: event,\n        }) === false) {\n            return;\n        }\n        // Prevent page scrolling.\n        event.preventDefault();\n        if (event.changedTouches) {\n            Array.from(event.changedTouches).forEach(({ identifier, pageX, pageY, }) => {\n                const pointer = $pointers.get(identifier);\n                if (pointer) {\n                    Object.assign(pointer, {\n                        endX: pageX,\n                        endY: pageY,\n                    });\n                }\n            });\n        }\n        else {\n            const { pointerId = 0, pageX, pageY } = event;\n            const pointer = $pointers.get(pointerId);\n            if (pointer) {\n                Object.assign(pointer, {\n                    endX: pageX,\n                    endY: pageY,\n                });\n            }\n        }\n        const detail = {\n            action: $action,\n            relatedEvent: event,\n        };\n        if ($action === ACTION_TRANSFORM) {\n            const pointers2 = new Map($pointers);\n            let maxRotateRate = 0;\n            let maxScaleRate = 0;\n            let rotate = 0;\n            let scale = 0;\n            let centerX = event.pageX;\n            let centerY = event.pageY;\n            $pointers.forEach((pointer, pointerId) => {\n                pointers2.delete(pointerId);\n                pointers2.forEach((pointer2) => {\n                    let x1 = pointer2.startX - pointer.startX;\n                    let y1 = pointer2.startY - pointer.startY;\n                    let x2 = pointer2.endX - pointer.endX;\n                    let y2 = pointer2.endY - pointer.endY;\n                    let z1 = 0;\n                    let z2 = 0;\n                    let a1 = 0;\n                    let a2 = 0;\n                    if (x1 === 0) {\n                        if (y1 < 0) {\n                            a1 = Math.PI * 2;\n                        }\n                        else if (y1 > 0) {\n                            a1 = Math.PI;\n                        }\n                    }\n                    else if (x1 > 0) {\n                        a1 = (Math.PI / 2) + Math.atan(y1 / x1);\n                    }\n                    else if (x1 < 0) {\n                        a1 = (Math.PI * 1.5) + Math.atan(y1 / x1);\n                    }\n                    if (x2 === 0) {\n                        if (y2 < 0) {\n                            a2 = Math.PI * 2;\n                        }\n                        else if (y2 > 0) {\n                            a2 = Math.PI;\n                        }\n                    }\n                    else if (x2 > 0) {\n                        a2 = (Math.PI / 2) + Math.atan(y2 / x2);\n                    }\n                    else if (x2 < 0) {\n                        a2 = (Math.PI * 1.5) + Math.atan(y2 / x2);\n                    }\n                    if (a2 > 0 || a1 > 0) {\n                        const rotateRate = a2 - a1;\n                        const absRotateRate = Math.abs(rotateRate);\n                        if (absRotateRate > maxRotateRate) {\n                            maxRotateRate = absRotateRate;\n                            rotate = rotateRate;\n                            centerX = (pointer.startX + pointer2.startX) / 2;\n                            centerY = (pointer.startY + pointer2.startY) / 2;\n                        }\n                    }\n                    x1 = Math.abs(x1);\n                    y1 = Math.abs(y1);\n                    x2 = Math.abs(x2);\n                    y2 = Math.abs(y2);\n                    if (x1 > 0 && y1 > 0) {\n                        z1 = Math.sqrt((x1 * x1) + (y1 * y1));\n                    }\n                    else if (x1 > 0) {\n                        z1 = x1;\n                    }\n                    else if (y1 > 0) {\n                        z1 = y1;\n                    }\n                    if (x2 > 0 && y2 > 0) {\n                        z2 = Math.sqrt((x2 * x2) + (y2 * y2));\n                    }\n                    else if (x2 > 0) {\n                        z2 = x2;\n                    }\n                    else if (y2 > 0) {\n                        z2 = y2;\n                    }\n                    if (z1 > 0 && z2 > 0) {\n                        const scaleRate = (z2 - z1) / z1;\n                        const absScaleRate = Math.abs(scaleRate);\n                        if (absScaleRate > maxScaleRate) {\n                            maxScaleRate = absScaleRate;\n                            scale = scaleRate;\n                            centerX = (pointer.startX + pointer2.startX) / 2;\n                            centerY = (pointer.startY + pointer2.startY) / 2;\n                        }\n                    }\n                });\n            });\n            const rotatable = maxRotateRate > 0;\n            const scalable = maxScaleRate > 0;\n            if (rotatable && scalable) {\n                detail.rotate = rotate;\n                detail.scale = scale;\n                detail.centerX = centerX;\n                detail.centerY = centerY;\n            }\n            else if (rotatable) {\n                detail.action = ACTION_ROTATE;\n                detail.rotate = rotate;\n                detail.centerX = centerX;\n                detail.centerY = centerY;\n            }\n            else if (scalable) {\n                detail.action = ACTION_SCALE;\n                detail.scale = scale;\n                detail.centerX = centerX;\n                detail.centerY = centerY;\n            }\n            else {\n                detail.action = ACTION_NONE;\n            }\n        }\n        else {\n            const [pointer] = Array.from($pointers.values());\n            Object.assign(detail, pointer);\n        }\n        // Override the starting coordinate\n        $pointers.forEach((pointer) => {\n            pointer.startX = pointer.endX;\n            pointer.startY = pointer.endY;\n        });\n        if (detail.action !== ACTION_NONE) {\n            this.$emit(EVENT_ACTION, detail, {\n                cancelable: false,\n            });\n        }\n    }\n    $handlePointerUp(event) {\n        const { $action, $pointers } = this;\n        if (this.disabled || $action === ACTION_NONE) {\n            return;\n        }\n        if (this.$emit(EVENT_ACTION_END, {\n            action: $action,\n            relatedEvent: event,\n        }) === false) {\n            return;\n        }\n        event.preventDefault();\n        if (event.changedTouches) {\n            Array.from(event.changedTouches).forEach(({ identifier, }) => {\n                $pointers.delete(identifier);\n            });\n        }\n        else {\n            const { pointerId = 0 } = event;\n            $pointers.delete(pointerId);\n        }\n        if ($pointers.size === 0) {\n            this.style.willChange = '';\n            this.$action = ACTION_NONE;\n        }\n    }\n    $handleWheel(event) {\n        if (this.disabled) {\n            return;\n        }\n        event.preventDefault();\n        // Limit wheel speed to prevent zoom too fast (#21)\n        if (this.$wheeling) {\n            return;\n        }\n        this.$wheeling = true;\n        // Debounce by 50ms\n        setTimeout(() => {\n            this.$wheeling = false;\n        }, 50);\n        const delta = event.deltaY > 0 ? -1 : 1;\n        const scale = delta * this.scaleStep;\n        this.$emit(EVENT_ACTION, {\n            action: ACTION_SCALE,\n            scale,\n            relatedEvent: event,\n        }, {\n            cancelable: false,\n        });\n    }\n    /**\n     * Changes the current action to a new one.\n     * @param {string} action The new action.\n     * @returns {CropperCanvas} Returns `this` for chaining.\n     */\n    $setAction(action) {\n        if (isString(action)) {\n            this.$action = action;\n        }\n        return this;\n    }\n    /**\n     * Generates a real canvas element, with the image draw into if there is one.\n     * @param {object} [options] The available options.\n     * @param {number} [options.width] The width of the canvas.\n     * @param {number} [options.height] The height of the canvas.\n     * @param {Function} [options.beforeDraw] The function called before drawing the image onto the canvas.\n     * @returns {Promise} Returns a promise that resolves to the generated canvas element.\n     */\n    $toCanvas(options) {\n        return new Promise((resolve, reject) => {\n            if (!this.isConnected) {\n                reject(new Error('The current element is not connected to the DOM.'));\n                return;\n            }\n            const canvas = document.createElement('canvas');\n            let width = this.offsetWidth;\n            let height = this.offsetHeight;\n            let scale = 1;\n            if (isPlainObject(options)\n                && (isPositiveNumber(options.width) || isPositiveNumber(options.height))) {\n                ({ width, height } = getAdjustedSizes({\n                    aspectRatio: width / height,\n                    width: options.width,\n                    height: options.height,\n                }));\n                scale = width / this.offsetWidth;\n            }\n            canvas.width = width;\n            canvas.height = height;\n            const cropperImage = this.querySelector(this.$getTagNameOf(CROPPER_IMAGE));\n            if (!cropperImage) {\n                resolve(canvas);\n                return;\n            }\n            cropperImage.$ready().then((image) => {\n                const context = canvas.getContext('2d');\n                if (context) {\n                    const [a, b, c, d, e, f] = cropperImage.$getTransform();\n                    let newE = e;\n                    let newF = f;\n                    let destWidth = image.naturalWidth;\n                    let destHeight = image.naturalHeight;\n                    if (scale !== 1) {\n                        newE *= scale;\n                        newF *= scale;\n                        destWidth *= scale;\n                        destHeight *= scale;\n                    }\n                    const centerX = destWidth / 2;\n                    const centerY = destHeight / 2;\n                    context.fillStyle = 'transparent';\n                    context.fillRect(0, 0, width, height);\n                    if (isPlainObject(options) && isFunction(options.beforeDraw)) {\n                        options.beforeDraw.call(this, context, canvas);\n                    }\n                    context.save();\n                    // Move the transform origin to the center of the image.\n                    // https://developer.mozilla.org/en-US/docs/Web/CSS/transform-origin\n                    context.translate(centerX, centerY);\n                    context.transform(a, b, c, d, newE, newF);\n                    // Reset the transform origin to the top-left of the image.\n                    context.translate(-centerX, -centerY);\n                    context.drawImage(image, 0, 0, destWidth, destHeight);\n                    context.restore();\n                }\n                resolve(canvas);\n            }).catch(reject);\n        });\n    }\n}\nCropperCanvas.$name = CROPPER_CANVAS;\nCropperCanvas.$version = '2.0.0';\n\nexport { CropperCanvas as default };\n","import CropperElement from '@cropper/element';\nimport { CROPPER_IMAGE, CROPPER_CANVAS, on, EVENT_ACTION_START, EVENT_ACTION_END, EVENT_ACTION, EVENT_LOAD, off, ACTION_TRANSFORM, ACTION_ROTATE, ACTION_SCALE, ACTION_NONE, CROPPER_SELECTION, ACTION_MOVE, once, EVENT_ERROR, isFunction, isNumber, toAngleInRadian, multiplyMatrices, EVENT_TRANSFORM } from '@cropper/utils';\n\nvar style = `:host{display:inline-block}img{display:block;height:100%;max-height:none!important;max-width:none!important;min-height:0!important;min-width:0!important;width:100%}`;\n\nconst canvasCache = new WeakMap();\nconst NATIVE_ATTRIBUTES = [\n    'alt',\n    'crossorigin',\n    'decoding',\n    'importance',\n    'loading',\n    'referrerpolicy',\n    'sizes',\n    'src',\n    'srcset',\n];\nclass CropperImage extends CropperElement {\n    constructor() {\n        super(...arguments);\n        this.$matrix = [1, 0, 0, 1, 0, 0];\n        this.$onLoad = null;\n        this.$onCanvasAction = null;\n        this.$onCanvasActionEnd = null;\n        this.$onCanvasActionStart = null;\n        this.$actionStartTarget = null;\n        this.$style = style;\n        this.$image = new Image();\n        this.initialCenterSize = 'contain';\n        this.rotatable = false;\n        this.scalable = false;\n        this.skewable = false;\n        this.slottable = false;\n        this.translatable = false;\n    }\n    set $canvas(element) {\n        canvasCache.set(this, element);\n    }\n    get $canvas() {\n        return canvasCache.get(this);\n    }\n    static get observedAttributes() {\n        return super.observedAttributes.concat(NATIVE_ATTRIBUTES, [\n            'initial-center-size',\n            'rotatable',\n            'scalable',\n            'skewable',\n            'translatable',\n        ]);\n    }\n    attributeChangedCallback(name, oldValue, newValue) {\n        if (Object.is(newValue, oldValue)) {\n            return;\n        }\n        super.attributeChangedCallback(name, oldValue, newValue);\n        // Inherits the native attributes\n        if (NATIVE_ATTRIBUTES.includes(name)) {\n            this.$image.setAttribute(name, newValue);\n        }\n    }\n    $propertyChangedCallback(name, oldValue, newValue) {\n        if (Object.is(newValue, oldValue)) {\n            return;\n        }\n        super.$propertyChangedCallback(name, oldValue, newValue);\n        switch (name) {\n            case 'initialCenterSize':\n                this.$nextTick(() => {\n                    this.$center(newValue);\n                });\n                break;\n        }\n    }\n    connectedCallback() {\n        super.connectedCallback();\n        const { $image } = this;\n        const $canvas = this.closest(this.$getTagNameOf(CROPPER_CANVAS));\n        if ($canvas) {\n            this.$canvas = $canvas;\n            this.$setStyles({\n                // Make it a block element to avoid side effects (#1074).\n                display: 'block',\n                position: 'absolute',\n            });\n            this.$onCanvasActionStart = (event) => {\n                var _a, _b;\n                this.$actionStartTarget = (_b = (_a = event.detail) === null || _a === void 0 ? void 0 : _a.relatedEvent) === null || _b === void 0 ? void 0 : _b.target;\n            };\n            this.$onCanvasActionEnd = () => {\n                this.$actionStartTarget = null;\n            };\n            this.$onCanvasAction = this.$handleAction.bind(this);\n            on($canvas, EVENT_ACTION_START, this.$onCanvasActionStart);\n            on($canvas, EVENT_ACTION_END, this.$onCanvasActionEnd);\n            on($canvas, EVENT_ACTION, this.$onCanvasAction);\n        }\n        this.$onLoad = this.$handleLoad.bind(this);\n        on($image, EVENT_LOAD, this.$onLoad);\n        this.$getShadowRoot().appendChild($image);\n    }\n    disconnectedCallback() {\n        const { $image, $canvas } = this;\n        if ($canvas) {\n            if (this.$onCanvasActionStart) {\n                off($canvas, EVENT_ACTION_START, this.$onCanvasActionStart);\n                this.$onCanvasActionStart = null;\n            }\n            if (this.$onCanvasActionEnd) {\n                off($canvas, EVENT_ACTION_END, this.$onCanvasActionEnd);\n                this.$onCanvasActionEnd = null;\n            }\n            if (this.$onCanvasAction) {\n                off($canvas, EVENT_ACTION, this.$onCanvasAction);\n                this.$onCanvasAction = null;\n            }\n        }\n        if ($image && this.$onLoad) {\n            off($image, EVENT_LOAD, this.$onLoad);\n            this.$onLoad = null;\n        }\n        this.$getShadowRoot().removeChild($image);\n        super.disconnectedCallback();\n    }\n    $handleLoad() {\n        const { $image } = this;\n        this.$setStyles({\n            width: $image.naturalWidth,\n            height: $image.naturalHeight,\n        });\n        if (this.$canvas) {\n            this.$center(this.initialCenterSize);\n        }\n    }\n    $handleAction(event) {\n        if (this.hidden || !(this.rotatable || this.scalable || this.translatable)) {\n            return;\n        }\n        const { $canvas } = this;\n        const { detail } = event;\n        if (detail) {\n            const { relatedEvent } = detail;\n            let { action } = detail;\n            if (action === ACTION_TRANSFORM && (!this.rotatable || !this.scalable)) {\n                if (this.rotatable) {\n                    action = ACTION_ROTATE;\n                }\n                else if (this.scalable) {\n                    action = ACTION_SCALE;\n                }\n                else {\n                    action = ACTION_NONE;\n                }\n            }\n            switch (action) {\n                case ACTION_MOVE:\n                    if (this.translatable) {\n                        let $selection = null;\n                        if (relatedEvent) {\n                            $selection = relatedEvent.target.closest(this.$getTagNameOf(CROPPER_SELECTION));\n                        }\n                        if (!$selection) {\n                            $selection = $canvas.querySelector(this.$getTagNameOf(CROPPER_SELECTION));\n                        }\n                        if ($selection && $selection.multiple && !$selection.active) {\n                            $selection = $canvas.querySelector(`${this.$getTagNameOf(CROPPER_SELECTION)}[active]`);\n                        }\n                        if (!$selection || $selection.hidden || !$selection.movable || $selection.dynamic\n                            || !(this.$actionStartTarget && $selection.contains(this.$actionStartTarget))) {\n                            this.$move(detail.endX - detail.startX, detail.endY - detail.startY);\n                        }\n                    }\n                    break;\n                case ACTION_ROTATE:\n                    if (this.rotatable) {\n                        if (relatedEvent) {\n                            const { x, y } = this.getBoundingClientRect();\n                            this.$rotate(detail.rotate, relatedEvent.clientX - x, relatedEvent.clientY - y);\n                        }\n                        else {\n                            this.$rotate(detail.rotate);\n                        }\n                    }\n                    break;\n                case ACTION_SCALE:\n                    if (this.scalable) {\n                        if (relatedEvent) {\n                            const $selection = relatedEvent.target.closest(this.$getTagNameOf(CROPPER_SELECTION));\n                            if (!$selection\n                                || !$selection.zoomable\n                                || ($selection.zoomable && $selection.dynamic)) {\n                                const { x, y } = this.getBoundingClientRect();\n                                this.$zoom(detail.scale, relatedEvent.clientX - x, relatedEvent.clientY - y);\n                            }\n                        }\n                        else {\n                            this.$zoom(detail.scale);\n                        }\n                    }\n                    break;\n                case ACTION_TRANSFORM:\n                    if (this.rotatable && this.scalable) {\n                        const { rotate } = detail;\n                        let { scale } = detail;\n                        if (scale < 0) {\n                            scale = 1 / (1 - scale);\n                        }\n                        else {\n                            scale += 1;\n                        }\n                        const cos = Math.cos(rotate);\n                        const sin = Math.sin(rotate);\n                        const [scaleX, skewY, skewX, scaleY] = [\n                            cos * scale,\n                            sin * scale,\n                            -sin * scale,\n                            cos * scale,\n                        ];\n                        if (relatedEvent) {\n                            const clientRect = this.getBoundingClientRect();\n                            const x = relatedEvent.clientX - clientRect.x;\n                            const y = relatedEvent.clientY - clientRect.y;\n                            const [a, b, c, d] = this.$matrix;\n                            const originX = clientRect.width / 2;\n                            const originY = clientRect.height / 2;\n                            const moveX = x - originX;\n                            const moveY = y - originY;\n                            const translateX = ((moveX * d) - (c * moveY)) / ((a * d) - (c * b));\n                            const translateY = ((moveY * a) - (b * moveX)) / ((a * d) - (c * b));\n                            /**\n                             * Equals to\n                             * this.$rotate(rotate, x, y);\n                             * this.$scale(scale, x, y);\n                             */\n                            this.$transform(scaleX, skewY, skewX, scaleY, translateX * (1 - scaleX) + translateY * skewX, translateY * (1 - scaleY) + translateX * skewY);\n                        }\n                        else {\n                            /**\n                             * Equals to\n                             * this.$rotate(rotate);\n                             * this.$scale(scale);\n                             */\n                            this.$transform(scaleX, skewY, skewX, scaleY, 0, 0);\n                        }\n                    }\n                    break;\n            }\n        }\n    }\n    /**\n     * Defers the callback to execute after successfully loading the image.\n     * @param {Function} [callback] The callback to execute after successfully loading the image.\n     * @returns {Promise} Returns a promise that resolves to the image element.\n     */\n    $ready(callback) {\n        const { $image } = this;\n        const promise = new Promise((resolve, reject) => {\n            const error = new Error('Failed to load the image source');\n            if ($image.complete) {\n                if ($image.naturalWidth > 0 && $image.naturalHeight > 0) {\n                    resolve($image);\n                }\n                else {\n                    reject(error);\n                }\n            }\n            else {\n                const onLoad = () => {\n                    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n                    off($image, EVENT_ERROR, onError);\n                    resolve($image);\n                };\n                const onError = () => {\n                    off($image, EVENT_LOAD, onLoad);\n                    reject(error);\n                };\n                once($image, EVENT_LOAD, onLoad);\n                once($image, EVENT_ERROR, onError);\n            }\n        });\n        if (isFunction(callback)) {\n            promise.then((image) => {\n                callback(image);\n                return image;\n            });\n        }\n        return promise;\n    }\n    /**\n     * Aligns the image to the center of its parent element.\n     * @param {string} [size] The size of the image.\n     * @returns {CropperImage} Returns `this` for chaining.\n     */\n    $center(size) {\n        const { parentElement } = this;\n        if (!parentElement) {\n            return this;\n        }\n        const container = parentElement.getBoundingClientRect();\n        const containerWidth = container.width;\n        const containerHeight = container.height;\n        const { x, y, width, height, } = this.getBoundingClientRect();\n        const startX = x + (width / 2);\n        const startY = y + (height / 2);\n        const endX = container.x + (containerWidth / 2);\n        const endY = container.y + (containerHeight / 2);\n        this.$move(endX - startX, endY - startY);\n        if (size && (width !== containerWidth || height !== containerHeight)) {\n            const scaleX = containerWidth / width;\n            const scaleY = containerHeight / height;\n            switch (size) {\n                case 'cover':\n                    this.$scale(Math.max(scaleX, scaleY));\n                    break;\n                case 'contain':\n                    this.$scale(Math.min(scaleX, scaleY));\n                    break;\n            }\n        }\n        return this;\n    }\n    /**\n     * Moves the image.\n     * @param {number} x The moving distance in the horizontal direction.\n     * @param {number} [y] The moving distance in the vertical direction.\n     * @returns {CropperImage} Returns `this` for chaining.\n     */\n    $move(x, y = x) {\n        if (this.translatable && isNumber(x) && isNumber(y)) {\n            const [a, b, c, d] = this.$matrix;\n            const e = ((x * d) - (c * y)) / ((a * d) - (c * b));\n            const f = ((y * a) - (b * x)) / ((a * d) - (c * b));\n            this.$translate(e, f);\n        }\n        return this;\n    }\n    /**\n     * Moves the image to a specific position.\n     * @param {number} x The new position in the horizontal direction.\n     * @param {number} [y] The new position in the vertical direction.\n     * @returns {CropperImage} Returns `this` for chaining.\n     */\n    $moveTo(x, y = x) {\n        if (this.translatable && isNumber(x) && isNumber(y)) {\n            const [a, b, c, d] = this.$matrix;\n            const e = ((x * d) - (c * y)) / ((a * d) - (c * b));\n            const f = ((y * a) - (b * x)) / ((a * d) - (c * b));\n            this.$setTransform(a, b, c, d, e, f);\n        }\n        return this;\n    }\n    /**\n     * Rotates the image.\n     * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/transform-function/rotate}\n     * {@link https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/rotate}\n     * @param {number|string} angle The rotation angle (in radians).\n     * @param {number} [x] The rotation origin in the horizontal, defaults to the center of the image.\n     * @param {number} [y] The rotation origin in the vertical, defaults to the center of the image.\n     * @returns {CropperImage} Returns `this` for chaining.\n     */\n    $rotate(angle, x, y) {\n        if (this.rotatable) {\n            const radian = toAngleInRadian(angle);\n            const cos = Math.cos(radian);\n            const sin = Math.sin(radian);\n            const [scaleX, skewY, skewX, scaleY] = [cos, sin, -sin, cos];\n            if (isNumber(x) && isNumber(y)) {\n                const [a, b, c, d] = this.$matrix;\n                const { width, height } = this.getBoundingClientRect();\n                const originX = width / 2;\n                const originY = height / 2;\n                const moveX = x - originX;\n                const moveY = y - originY;\n                const translateX = ((moveX * d) - (c * moveY)) / ((a * d) - (c * b));\n                const translateY = ((moveY * a) - (b * moveX)) / ((a * d) - (c * b));\n                /**\n                 * Equals to\n                 * this.$translate(translateX, translateX);\n                 * this.$rotate(angle);\n                 * this.$translate(-translateX, -translateX);\n                 */\n                this.$transform(scaleX, skewY, skewX, scaleY, translateX * (1 - scaleX) - translateY * skewX, translateY * (1 - scaleY) - translateX * skewY);\n            }\n            else {\n                this.$transform(scaleX, skewY, skewX, scaleY, 0, 0);\n            }\n        }\n        return this;\n    }\n    /**\n     * Zooms the image.\n     * @param {number} scale The zoom factor. Positive numbers for zooming in, and negative numbers for zooming out.\n     * @param {number} [x] The zoom origin in the horizontal, defaults to the center of the image.\n     * @param {number} [y] The zoom origin in the vertical, defaults to the center of the image.\n     * @returns {CropperImage} Returns `this` for chaining.\n     */\n    $zoom(scale, x, y) {\n        if (!this.scalable || scale === 0) {\n            return this;\n        }\n        if (scale < 0) {\n            scale = 1 / (1 - scale);\n        }\n        else {\n            scale += 1;\n        }\n        if (isNumber(x) && isNumber(y)) {\n            const [a, b, c, d] = this.$matrix;\n            const { width, height } = this.getBoundingClientRect();\n            const originX = width / 2;\n            const originY = height / 2;\n            const moveX = x - originX;\n            const moveY = y - originY;\n            const translateX = ((moveX * d) - (c * moveY)) / ((a * d) - (c * b));\n            const translateY = ((moveY * a) - (b * moveX)) / ((a * d) - (c * b));\n            /**\n             * Equals to\n             * this.$translate(translateX, translateX);\n             * this.$scale(scale);\n             * this.$translate(-translateX, -translateX);\n             */\n            this.$transform(scale, 0, 0, scale, translateX * (1 - scale), translateY * (1 - scale));\n        }\n        else {\n            this.$scale(scale);\n        }\n        return this;\n    }\n    /**\n     * Scales the image.\n     * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/transform-function/scale}\n     * {@link https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/scale}\n     * @param {number} x The scaling factor in the horizontal direction.\n     * @param {number} [y] The scaling factor in the vertical direction.\n     * @returns {CropperImage} Returns `this` for chaining.\n     */\n    $scale(x, y = x) {\n        if (this.scalable) {\n            this.$transform(x, 0, 0, y, 0, 0);\n        }\n        return this;\n    }\n    /**\n     * Skews the image.\n     * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/transform-function/skew}\n     * {@link https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/transform}\n     * @param {number|string} x The skewing angle in the horizontal direction.\n     * @param {number|string} [y] The skewing angle in the vertical direction.\n     * @returns {CropperImage} Returns `this` for chaining.\n     */\n    $skew(x, y = 0) {\n        if (this.skewable) {\n            const radianX = toAngleInRadian(x);\n            const radianY = toAngleInRadian(y);\n            this.$transform(1, Math.tan(radianY), Math.tan(radianX), 1, 0, 0);\n        }\n        return this;\n    }\n    /**\n     * Translates the image.\n     * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/transform-function/translate}\n     * {@link https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/translate}\n     * @param {number} x The translating distance in the horizontal direction.\n     * @param {number} [y] The translating distance in the vertical direction.\n     * @returns {CropperImage} Returns `this` for chaining.\n     */\n    $translate(x, y = x) {\n        if (this.translatable && isNumber(x) && isNumber(y)) {\n            this.$transform(1, 0, 0, 1, x, y);\n        }\n        return this;\n    }\n    /**\n     * Transforms the image.\n     * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/transform-function/matrix}\n     * {@link https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/transform}\n     * @param {number} a The scaling factor in the horizontal direction.\n     * @param {number} b The skewing angle in the vertical direction.\n     * @param {number} c The skewing angle in the horizontal direction.\n     * @param {number} d The scaling factor in the vertical direction.\n     * @param {number} e The translating distance in the horizontal direction.\n     * @param {number} f The translating distance in the vertical direction.\n     * @returns {CropperImage} Returns `this` for chaining.\n     */\n    $transform(a, b, c, d, e, f) {\n        if (isNumber(a)\n            && isNumber(b)\n            && isNumber(c)\n            && isNumber(d)\n            && isNumber(e)\n            && isNumber(f)) {\n            return this.$setTransform(multiplyMatrices(this.$matrix, [a, b, c, d, e, f]));\n        }\n        return this;\n    }\n    /**\n     * Resets (overrides) the current transform to the specific identity matrix.\n     * {@link https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/setTransform}\n     * @param {number|Array} a The scaling factor in the horizontal direction.\n     * @param {number} b The skewing angle in the vertical direction.\n     * @param {number} c The skewing angle in the horizontal direction.\n     * @param {number} d The scaling factor in the vertical direction.\n     * @param {number} e The translating distance in the horizontal direction.\n     * @param {number} f The translating distance in the vertical direction.\n     * @returns {CropperImage} Returns `this` for chaining.\n     */\n    $setTransform(a, b, c, d, e, f) {\n        if (this.rotatable || this.scalable || this.skewable || this.translatable) {\n            if (Array.isArray(a)) {\n                [a, b, c, d, e, f] = a;\n            }\n            if (isNumber(a)\n                && isNumber(b)\n                && isNumber(c)\n                && isNumber(d)\n                && isNumber(e)\n                && isNumber(f)) {\n                const oldMatrix = [...this.$matrix];\n                const newMatrix = [a, b, c, d, e, f];\n                if (this.$emit(EVENT_TRANSFORM, {\n                    matrix: newMatrix,\n                    oldMatrix,\n                }) === false) {\n                    return this;\n                }\n                this.$matrix = newMatrix;\n                this.style.transform = `matrix(${newMatrix.join(', ')})`;\n            }\n        }\n        return this;\n    }\n    /**\n     * Retrieves the current transformation matrix being applied to the element.\n     * {@link https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/getTransform}\n     * @returns {Array} Returns the readonly transformation matrix.\n     */\n    $getTransform() {\n        return this.$matrix.slice();\n    }\n    /**\n     * Resets the current transform to the initial identity matrix.\n     * {@link https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/resetTransform}\n     * @returns {CropperImage} Returns `this` for chaining.\n     */\n    $resetTransform() {\n        return this.$setTransform([1, 0, 0, 1, 0, 0]);\n    }\n}\nCropperImage.$name = CROPPER_IMAGE;\nCropperImage.$version = '2.0.0';\n\nexport { CropperImage as default };\n","import CropperElement from '@cropper/element';\nimport { CROPPER_SHADE, CROPPER_CANVAS, CROPPER_SELECTION, ACTION_SELECT, on, EVENT_ACTION_START, EVENT_ACTION_END, EVENT_CHANGE, off, isNumber, WINDOW } from '@cropper/utils';\n\nvar style = `:host{display:block;height:0;left:0;outline:var(--theme-color) solid 1px;position:relative;top:0;width:0}:host([transparent]){outline-color:transparent}`;\n\nconst canvasCache = new WeakMap();\nclass CropperShade extends CropperElement {\n    constructor() {\n        super(...arguments);\n        this.$onCanvasChange = null;\n        this.$onCanvasActionEnd = null;\n        this.$onCanvasActionStart = null;\n        this.$style = style;\n        this.x = 0;\n        this.y = 0;\n        this.width = 0;\n        this.height = 0;\n        this.slottable = false;\n        this.themeColor = 'rgba(0, 0, 0, 0.65)';\n    }\n    set $canvas(element) {\n        canvasCache.set(this, element);\n    }\n    get $canvas() {\n        return canvasCache.get(this);\n    }\n    static get observedAttributes() {\n        return super.observedAttributes.concat([\n            'height',\n            'width',\n            'x',\n            'y',\n        ]);\n    }\n    connectedCallback() {\n        super.connectedCallback();\n        const $canvas = this.closest(this.$getTagNameOf(CROPPER_CANVAS));\n        if ($canvas) {\n            this.$canvas = $canvas;\n            this.style.position = 'absolute';\n            const $selection = $canvas.querySelector(this.$getTagNameOf(CROPPER_SELECTION));\n            if ($selection) {\n                this.$onCanvasActionStart = (event) => {\n                    if ($selection.hidden && event.detail.action === ACTION_SELECT) {\n                        this.hidden = false;\n                    }\n                };\n                this.$onCanvasActionEnd = (event) => {\n                    if ($selection.hidden && event.detail.action === ACTION_SELECT) {\n                        this.hidden = true;\n                    }\n                };\n                this.$onCanvasChange = (event) => {\n                    const { x, y, width, height, } = event.detail;\n                    this.$change(x, y, width, height);\n                    if ($selection.hidden || (x === 0 && y === 0 && width === 0 && height === 0)) {\n                        this.hidden = true;\n                    }\n                };\n                on($canvas, EVENT_ACTION_START, this.$onCanvasActionStart);\n                on($canvas, EVENT_ACTION_END, this.$onCanvasActionEnd);\n                on($canvas, EVENT_CHANGE, this.$onCanvasChange);\n            }\n        }\n        this.$render();\n    }\n    disconnectedCallback() {\n        const { $canvas } = this;\n        if ($canvas) {\n            if (this.$onCanvasActionStart) {\n                off($canvas, EVENT_ACTION_START, this.$onCanvasActionStart);\n                this.$onCanvasActionStart = null;\n            }\n            if (this.$onCanvasActionEnd) {\n                off($canvas, EVENT_ACTION_END, this.$onCanvasActionEnd);\n                this.$onCanvasActionEnd = null;\n            }\n            if (this.$onCanvasChange) {\n                off($canvas, EVENT_CHANGE, this.$onCanvasChange);\n                this.$onCanvasChange = null;\n            }\n        }\n        super.disconnectedCallback();\n    }\n    /**\n     * Changes the position and/or size of the shade.\n     * @param {number} x The new position in the horizontal direction.\n     * @param {number} y The new position in the vertical direction.\n     * @param {number} [width] The new width.\n     * @param {number} [height] The new height.\n     * @returns {CropperShade} Returns `this` for chaining.\n     */\n    $change(x, y, width = this.width, height = this.height) {\n        if (!isNumber(x)\n            || !isNumber(y)\n            || !isNumber(width)\n            || !isNumber(height)\n            || (x === this.x && y === this.y && width === this.width && height === this.height)) {\n            return this;\n        }\n        if (this.hidden) {\n            this.hidden = false;\n        }\n        this.x = x;\n        this.y = y;\n        this.width = width;\n        this.height = height;\n        return this.$render();\n    }\n    /**\n     * Resets the shade to its initial position and size.\n     * @returns {CropperShade} Returns `this` for chaining.\n     */\n    $reset() {\n        return this.$change(0, 0, 0, 0);\n    }\n    /**\n     * Refreshes the position or size of the shade.\n     * @returns {CropperShade} Returns `this` for chaining.\n     */\n    $render() {\n        return this.$setStyles({\n            transform: `translate(${this.x}px, ${this.y}px)`,\n            width: this.width,\n            height: this.height,\n            outlineWidth: WINDOW.innerWidth,\n        });\n    }\n}\nCropperShade.$name = CROPPER_SHADE;\nCropperShade.$version = '2.0.0';\n\nexport { CropperShade as default };\n","import CropperElement from '@cropper/element';\nimport { CROPPER_HANDLE, ACTION_NONE } from '@cropper/utils';\n\nvar style = `:host{background-color:var(--theme-color);display:block}:host([action=move]),:host([action=select]){height:100%;left:0;position:absolute;top:0;width:100%}:host([action=move]){cursor:move}:host([action=select]){cursor:crosshair}:host([action$=-resize]){background-color:transparent;height:15px;position:absolute;width:15px}:host([action$=-resize]):after{background-color:var(--theme-color);content:\"\";display:block;height:5px;left:50%;position:absolute;top:50%;transform:translate(-50%,-50%);width:5px}:host([action=n-resize]),:host([action=s-resize]){cursor:ns-resize;left:50%;transform:translateX(-50%);width:100%}:host([action=n-resize]){top:-8px}:host([action=s-resize]){bottom:-8px}:host([action=e-resize]),:host([action=w-resize]){cursor:ew-resize;height:100%;top:50%;transform:translateY(-50%)}:host([action=e-resize]){right:-8px}:host([action=w-resize]){left:-8px}:host([action=ne-resize]){cursor:nesw-resize;right:-8px;top:-8px}:host([action=nw-resize]){cursor:nwse-resize;left:-8px;top:-8px}:host([action=se-resize]){bottom:-8px;cursor:nwse-resize;right:-8px}:host([action=se-resize]):after{height:15px;width:15px}@media (pointer:coarse){:host([action=se-resize]):after{height:10px;width:10px}}@media (pointer:fine){:host([action=se-resize]):after{height:5px;width:5px}}:host([action=sw-resize]){bottom:-8px;cursor:nesw-resize;left:-8px}:host([plain]){background-color:transparent}`;\n\nclass CropperHandle extends CropperElement {\n    constructor() {\n        super(...arguments);\n        this.$onCanvasCropEnd = null;\n        this.$onCanvasCropStart = null;\n        this.$style = style;\n        this.action = ACTION_NONE;\n        this.plain = false;\n        this.slottable = false;\n        this.themeColor = 'rgba(51, 153, 255, 0.5)';\n    }\n    static get observedAttributes() {\n        return super.observedAttributes.concat([\n            'action',\n            'plain',\n        ]);\n    }\n}\nCropperHandle.$name = CROPPER_HANDLE;\nCropperHandle.$version = '2.0.0';\n\nexport { CropperHandle as default };\n","import CropperElement from '@cropper/element';\nimport { CROPPER_SELECTION, EVENT_CHANGE, on, EVENT_KEYDOWN, off, isPositiveNumber, CROPPER_CANVAS, EVENT_ACTION_START, EVENT_ACTION_END, EVENT_ACTION, getAdjustedSizes, ACTION_SELECT, ACTION_SCALE, getOffset, ACTION_MOVE, ACTION_RESIZE_NORTHWEST, ACTION_RESIZE_SOUTHWEST, ACTION_RESIZE_NORTHEAST, ACTION_RESIZE_SOUTHEAST, isNumber, isPlainObject, CROPPER_IMAGE, isFunction, ACTION_RESIZE_WEST, ACTION_RESIZE_EAST, ACTION_RESIZE_SOUTH, ACTION_RESIZE_NORTH } from '@cropper/utils';\n\nvar style = `:host{display:block;left:0;position:relative;right:0}:host([outlined]){outline:1px solid var(--theme-color)}:host([multiple]){outline:1px dashed hsla(0,0%,100%,.5)}:host([multiple]):after{bottom:0;content:\"\";cursor:pointer;display:block;left:0;position:absolute;right:0;top:0}:host([multiple][active]){outline-color:var(--theme-color);z-index:1}:host([multiple])>*{visibility:hidden}:host([multiple][active])>*{visibility:visible}:host([multiple][active]):after{display:none}`;\n\nconst canvasCache = new WeakMap();\nclass CropperSelection extends CropperElement {\n    constructor() {\n        super(...arguments);\n        this.$onCanvasAction = null;\n        this.$onCanvasActionStart = null;\n        this.$onCanvasActionEnd = null;\n        this.$onDocumentKeyDown = null;\n        this.$action = '';\n        this.$actionStartTarget = null;\n        this.$changing = false;\n        this.$style = style;\n        this.$initialSelection = {\n            x: 0,\n            y: 0,\n            width: 0,\n            height: 0,\n        };\n        this.x = 0;\n        this.y = 0;\n        this.width = 0;\n        this.height = 0;\n        this.aspectRatio = NaN;\n        this.initialAspectRatio = NaN;\n        this.initialCoverage = NaN;\n        this.active = false;\n        // Deprecated as of v2.0.0-rc.0, use `dynamic` instead.\n        this.linked = false;\n        this.dynamic = false;\n        this.movable = false;\n        this.resizable = false;\n        this.zoomable = false;\n        this.multiple = false;\n        this.keyboard = false;\n        this.outlined = false;\n        this.precise = false;\n    }\n    set $canvas(element) {\n        canvasCache.set(this, element);\n    }\n    get $canvas() {\n        return canvasCache.get(this);\n    }\n    static get observedAttributes() {\n        return super.observedAttributes.concat([\n            'active',\n            'aspect-ratio',\n            'dynamic',\n            'height',\n            'initial-aspect-ratio',\n            'initial-coverage',\n            'keyboard',\n            'linked',\n            'movable',\n            'multiple',\n            'outlined',\n            'precise',\n            'resizable',\n            'width',\n            'x',\n            'y',\n            'zoomable',\n        ]);\n    }\n    $propertyChangedCallback(name, oldValue, newValue) {\n        if (Object.is(newValue, oldValue)) {\n            return;\n        }\n        super.$propertyChangedCallback(name, oldValue, newValue);\n        switch (name) {\n            case 'x':\n            case 'y':\n            case 'width':\n            case 'height':\n                if (!this.$changing) {\n                    this.$nextTick(() => {\n                        this.$change(this.x, this.y, this.width, this.height, this.aspectRatio, true);\n                    });\n                }\n                break;\n            case 'aspectRatio':\n            case 'initialAspectRatio':\n                this.$nextTick(() => {\n                    this.$initSelection();\n                });\n                break;\n            case 'initialCoverage':\n                this.$nextTick(() => {\n                    if (isPositiveNumber(newValue) && newValue <= 1) {\n                        this.$initSelection(true, true);\n                    }\n                });\n                break;\n            case 'keyboard':\n                this.$nextTick(() => {\n                    if (this.$canvas) {\n                        if (newValue) {\n                            if (!this.$onDocumentKeyDown) {\n                                this.$onDocumentKeyDown = this.$handleKeyDown.bind(this);\n                                on(this.ownerDocument, EVENT_KEYDOWN, this.$onDocumentKeyDown);\n                            }\n                        }\n                        else if (this.$onDocumentKeyDown) {\n                            off(this.ownerDocument, EVENT_KEYDOWN, this.$onDocumentKeyDown);\n                            this.$onDocumentKeyDown = null;\n                        }\n                    }\n                });\n                break;\n            case 'multiple':\n                this.$nextTick(() => {\n                    if (this.$canvas) {\n                        const selections = this.$getSelections();\n                        if (newValue) {\n                            selections.forEach((selection) => {\n                                selection.active = false;\n                            });\n                            this.active = true;\n                            this.$emit(EVENT_CHANGE, {\n                                x: this.x,\n                                y: this.y,\n                                width: this.width,\n                                height: this.height,\n                            });\n                        }\n                        else {\n                            this.active = false;\n                            selections.slice(1).forEach((selection) => {\n                                this.$removeSelection(selection);\n                            });\n                        }\n                    }\n                });\n                break;\n            case 'precise':\n                this.$nextTick(() => {\n                    this.$change(this.x, this.y);\n                });\n                break;\n            // Backwards compatible with 2.0.0-rc\n            case 'linked':\n                if (newValue) {\n                    this.dynamic = true;\n                }\n                break;\n        }\n    }\n    connectedCallback() {\n        super.connectedCallback();\n        const $canvas = this.closest(this.$getTagNameOf(CROPPER_CANVAS));\n        if ($canvas) {\n            this.$canvas = $canvas;\n            this.$setStyles({\n                position: 'absolute',\n                transform: `translate(${this.x}px, ${this.y}px)`,\n            });\n            if (!this.hidden) {\n                this.$render();\n            }\n            this.$initSelection(true);\n            this.$onCanvasActionStart = this.$handleActionStart.bind(this);\n            this.$onCanvasActionEnd = this.$handleActionEnd.bind(this);\n            this.$onCanvasAction = this.$handleAction.bind(this);\n            on($canvas, EVENT_ACTION_START, this.$onCanvasActionStart);\n            on($canvas, EVENT_ACTION_END, this.$onCanvasActionEnd);\n            on($canvas, EVENT_ACTION, this.$onCanvasAction);\n        }\n        else {\n            this.$render();\n        }\n    }\n    disconnectedCallback() {\n        const { $canvas } = this;\n        if ($canvas) {\n            if (this.$onCanvasActionStart) {\n                off($canvas, EVENT_ACTION_START, this.$onCanvasActionStart);\n                this.$onCanvasActionStart = null;\n            }\n            if (this.$onCanvasActionEnd) {\n                off($canvas, EVENT_ACTION_END, this.$onCanvasActionEnd);\n                this.$onCanvasActionEnd = null;\n            }\n            if (this.$onCanvasAction) {\n                off($canvas, EVENT_ACTION, this.$onCanvasAction);\n                this.$onCanvasAction = null;\n            }\n        }\n        super.disconnectedCallback();\n    }\n    $getSelections() {\n        let selections = [];\n        if (this.parentElement) {\n            selections = Array.from(this.parentElement.querySelectorAll(this.$getTagNameOf(CROPPER_SELECTION)));\n        }\n        return selections;\n    }\n    $initSelection(center = false, resize = false) {\n        const { initialCoverage, parentElement } = this;\n        if (isPositiveNumber(initialCoverage) && parentElement) {\n            const aspectRatio = this.aspectRatio || this.initialAspectRatio;\n            let width = (resize ? 0 : this.width) || parentElement.offsetWidth * initialCoverage;\n            let height = (resize ? 0 : this.height) || parentElement.offsetHeight * initialCoverage;\n            if (isPositiveNumber(aspectRatio)) {\n                ({ width, height } = getAdjustedSizes({ aspectRatio, width, height }));\n            }\n            this.$change(this.x, this.y, width, height);\n            if (center) {\n                this.$center();\n            }\n            // Overrides the initial position and size\n            this.$initialSelection = {\n                x: this.x,\n                y: this.y,\n                width: this.width,\n                height: this.height,\n            };\n        }\n    }\n    $createSelection() {\n        const newSelection = this.cloneNode(true);\n        if (this.hasAttribute('id')) {\n            newSelection.removeAttribute('id');\n        }\n        newSelection.initialCoverage = NaN;\n        this.active = false;\n        if (this.parentElement) {\n            this.parentElement.insertBefore(newSelection, this.nextSibling);\n        }\n        return newSelection;\n    }\n    $removeSelection(selection = this) {\n        if (this.parentElement) {\n            const selections = this.$getSelections();\n            if (selections.length > 1) {\n                const index = selections.indexOf(selection);\n                const activeSelection = selections[index + 1] || selections[index - 1];\n                if (activeSelection) {\n                    selection.active = false;\n                    this.parentElement.removeChild(selection);\n                    activeSelection.active = true;\n                    activeSelection.$emit(EVENT_CHANGE, {\n                        x: activeSelection.x,\n                        y: activeSelection.y,\n                        width: activeSelection.width,\n                        height: activeSelection.height,\n                    });\n                }\n            }\n            else {\n                this.$clear();\n            }\n        }\n    }\n    $handleActionStart(event) {\n        var _a, _b;\n        const relatedTarget = (_b = (_a = event.detail) === null || _a === void 0 ? void 0 : _a.relatedEvent) === null || _b === void 0 ? void 0 : _b.target;\n        this.$action = '';\n        this.$actionStartTarget = relatedTarget;\n        if (!this.hidden\n            && this.multiple\n            && !this.active\n            && relatedTarget === this\n            && this.parentElement) {\n            this.$getSelections().forEach((selection) => {\n                selection.active = false;\n            });\n            this.active = true;\n            this.$emit(EVENT_CHANGE, {\n                x: this.x,\n                y: this.y,\n                width: this.width,\n                height: this.height,\n            });\n        }\n    }\n    $handleAction(event) {\n        const { currentTarget, detail } = event;\n        if (!currentTarget || !detail) {\n            return;\n        }\n        const { relatedEvent } = detail;\n        let { action } = detail;\n        // Switching to another selection\n        if (!action && this.multiple) {\n            // Get the `action` property from the focusing in selection\n            action = this.$action || (relatedEvent === null || relatedEvent === void 0 ? void 0 : relatedEvent.target.action);\n            this.$action = action;\n        }\n        if (!action\n            || (this.hidden && action !== ACTION_SELECT)\n            || (this.multiple && !this.active && action !== ACTION_SCALE)) {\n            return;\n        }\n        const moveX = detail.endX - detail.startX;\n        const moveY = detail.endY - detail.startY;\n        const { width, height } = this;\n        let { aspectRatio } = this;\n        // Locking aspect ratio by holding shift key\n        if (!isPositiveNumber(aspectRatio) && relatedEvent.shiftKey) {\n            aspectRatio = isPositiveNumber(width) && isPositiveNumber(height) ? width / height : 1;\n        }\n        switch (action) {\n            case ACTION_SELECT:\n                if (moveX !== 0 && moveY !== 0) {\n                    const { $canvas } = this;\n                    const offset = getOffset(currentTarget);\n                    (this.multiple && !this.hidden ? this.$createSelection() : this).$change(detail.startX - offset.left, detail.startY - offset.top, Math.abs(moveX), Math.abs(moveY), aspectRatio);\n                    if (moveX < 0) {\n                        if (moveY < 0) {\n                            // ↖️\n                            action = ACTION_RESIZE_NORTHWEST;\n                        }\n                        else if (moveY > 0) {\n                            // ↙️\n                            action = ACTION_RESIZE_SOUTHWEST;\n                        }\n                    }\n                    else if (moveX > 0) {\n                        if (moveY < 0) {\n                            // ↗️\n                            action = ACTION_RESIZE_NORTHEAST;\n                        }\n                        else if (moveY > 0) {\n                            // ↘️\n                            action = ACTION_RESIZE_SOUTHEAST;\n                        }\n                    }\n                    if ($canvas) {\n                        $canvas.$action = action;\n                    }\n                }\n                break;\n            case ACTION_MOVE:\n                if (this.movable && (this.dynamic\n                    || (this.$actionStartTarget && this.contains(this.$actionStartTarget)))) {\n                    this.$move(moveX, moveY);\n                }\n                break;\n            case ACTION_SCALE:\n                if (relatedEvent && this.zoomable && (this.dynamic\n                    || this.contains(relatedEvent.target))) {\n                    const offset = getOffset(currentTarget);\n                    this.$zoom(detail.scale, relatedEvent.pageX - offset.left, relatedEvent.pageY - offset.top);\n                }\n                break;\n            default:\n                this.$resize(action, moveX, moveY, aspectRatio);\n        }\n    }\n    $handleActionEnd() {\n        this.$action = '';\n        this.$actionStartTarget = null;\n    }\n    $handleKeyDown(event) {\n        if (this.hidden\n            || !this.keyboard\n            || (this.multiple && !this.active)\n            || event.defaultPrevented) {\n            return;\n        }\n        const { activeElement } = document;\n        // Disable keyboard control when input something\n        if (activeElement && (['INPUT', 'TEXTAREA'].includes(activeElement.tagName)\n            || ['true', 'plaintext-only'].includes(activeElement.contentEditable))) {\n            return;\n        }\n        switch (event.key) {\n            case 'Backspace':\n                if (event.metaKey) {\n                    event.preventDefault();\n                    this.$removeSelection();\n                }\n                break;\n            case 'Delete':\n                event.preventDefault();\n                this.$removeSelection();\n                break;\n            // Move to the left\n            case 'ArrowLeft':\n                event.preventDefault();\n                this.$move(-1, 0);\n                break;\n            // Move to the right\n            case 'ArrowRight':\n                event.preventDefault();\n                this.$move(1, 0);\n                break;\n            // Move to the top\n            case 'ArrowUp':\n                event.preventDefault();\n                this.$move(0, -1);\n                break;\n            // Move to the bottom\n            case 'ArrowDown':\n                event.preventDefault();\n                this.$move(0, 1);\n                break;\n            case '+':\n                event.preventDefault();\n                this.$zoom(0.1);\n                break;\n            case '-':\n                event.preventDefault();\n                this.$zoom(-0.1);\n                break;\n        }\n    }\n    /**\n     * Aligns the selection to the center of its parent element.\n     * @returns {CropperSelection} Returns `this` for chaining.\n     */\n    $center() {\n        const { parentElement } = this;\n        if (!parentElement) {\n            return this;\n        }\n        const x = (parentElement.offsetWidth - this.width) / 2;\n        const y = (parentElement.offsetHeight - this.height) / 2;\n        return this.$change(x, y);\n    }\n    /**\n     * Moves the selection.\n     * @param {number} x The moving distance in the horizontal direction.\n     * @param {number} [y] The moving distance in the vertical direction.\n     * @returns {CropperSelection} Returns `this` for chaining.\n     */\n    $move(x, y = x) {\n        return this.$moveTo(this.x + x, this.y + y);\n    }\n    /**\n     * Moves the selection to a specific position.\n     * @param {number} x The new position in the horizontal direction.\n     * @param {number} [y] The new position in the vertical direction.\n     * @returns {CropperSelection} Returns `this` for chaining.\n     */\n    $moveTo(x, y = x) {\n        if (!this.movable) {\n            return this;\n        }\n        return this.$change(x, y);\n    }\n    /**\n     * Adjusts the size the selection on a specific side or corner.\n     * @param {string} action Indicates the side or corner to resize.\n     * @param {number} [offsetX] The horizontal offset of the specific side or corner.\n     * @param {number} [offsetY] The vertical offset of the specific side or corner.\n     * @param {number} [aspectRatio] The aspect ratio for computing the new size if it is necessary.\n     * @returns {CropperSelection} Returns `this` for chaining.\n     */\n    $resize(action, offsetX = 0, offsetY = 0, aspectRatio = this.aspectRatio) {\n        if (!this.resizable) {\n            return this;\n        }\n        const hasValidAspectRatio = isPositiveNumber(aspectRatio);\n        const { $canvas } = this;\n        let { x, y, width, height, } = this;\n        switch (action) {\n            case ACTION_RESIZE_NORTH:\n                y += offsetY;\n                height -= offsetY;\n                if (height < 0) {\n                    action = ACTION_RESIZE_SOUTH;\n                    height = -height;\n                    y -= height;\n                }\n                if (hasValidAspectRatio) {\n                    offsetX = offsetY * aspectRatio;\n                    x += offsetX / 2;\n                    width -= offsetX;\n                    if (width < 0) {\n                        width = -width;\n                        x -= width;\n                    }\n                }\n                break;\n            case ACTION_RESIZE_EAST:\n                width += offsetX;\n                if (width < 0) {\n                    action = ACTION_RESIZE_WEST;\n                    width = -width;\n                    x -= width;\n                }\n                if (hasValidAspectRatio) {\n                    offsetY = offsetX / aspectRatio;\n                    y -= offsetY / 2;\n                    height += offsetY;\n                    if (height < 0) {\n                        height = -height;\n                        y -= height;\n                    }\n                }\n                break;\n            case ACTION_RESIZE_SOUTH:\n                height += offsetY;\n                if (height < 0) {\n                    action = ACTION_RESIZE_NORTH;\n                    height = -height;\n                    y -= height;\n                }\n                if (hasValidAspectRatio) {\n                    offsetX = offsetY * aspectRatio;\n                    x -= offsetX / 2;\n                    width += offsetX;\n                    if (width < 0) {\n                        width = -width;\n                        x -= width;\n                    }\n                }\n                break;\n            case ACTION_RESIZE_WEST:\n                x += offsetX;\n                width -= offsetX;\n                if (width < 0) {\n                    action = ACTION_RESIZE_EAST;\n                    width = -width;\n                    x -= width;\n                }\n                if (hasValidAspectRatio) {\n                    offsetY = offsetX / aspectRatio;\n                    y += offsetY / 2;\n                    height -= offsetY;\n                    if (height < 0) {\n                        height = -height;\n                        y -= height;\n                    }\n                }\n                break;\n            case ACTION_RESIZE_NORTHEAST:\n                if (hasValidAspectRatio) {\n                    offsetY = -offsetX / aspectRatio;\n                }\n                y += offsetY;\n                height -= offsetY;\n                width += offsetX;\n                if (width < 0 && height < 0) {\n                    action = ACTION_RESIZE_SOUTHWEST;\n                    width = -width;\n                    height = -height;\n                    x -= width;\n                    y -= height;\n                }\n                else if (width < 0) {\n                    action = ACTION_RESIZE_NORTHWEST;\n                    width = -width;\n                    x -= width;\n                }\n                else if (height < 0) {\n                    action = ACTION_RESIZE_SOUTHEAST;\n                    height = -height;\n                    y -= height;\n                }\n                break;\n            case ACTION_RESIZE_NORTHWEST:\n                if (hasValidAspectRatio) {\n                    offsetY = offsetX / aspectRatio;\n                }\n                x += offsetX;\n                y += offsetY;\n                width -= offsetX;\n                height -= offsetY;\n                if (width < 0 && height < 0) {\n                    action = ACTION_RESIZE_SOUTHEAST;\n                    width = -width;\n                    height = -height;\n                    x -= width;\n                    y -= height;\n                }\n                else if (width < 0) {\n                    action = ACTION_RESIZE_NORTHEAST;\n                    width = -width;\n                    x -= width;\n                }\n                else if (height < 0) {\n                    action = ACTION_RESIZE_SOUTHWEST;\n                    height = -height;\n                    y -= height;\n                }\n                break;\n            case ACTION_RESIZE_SOUTHEAST:\n                if (hasValidAspectRatio) {\n                    offsetY = offsetX / aspectRatio;\n                }\n                width += offsetX;\n                height += offsetY;\n                if (width < 0 && height < 0) {\n                    action = ACTION_RESIZE_NORTHWEST;\n                    width = -width;\n                    height = -height;\n                    x -= width;\n                    y -= height;\n                }\n                else if (width < 0) {\n                    action = ACTION_RESIZE_SOUTHWEST;\n                    width = -width;\n                    x -= width;\n                }\n                else if (height < 0) {\n                    action = ACTION_RESIZE_NORTHEAST;\n                    height = -height;\n                    y -= height;\n                }\n                break;\n            case ACTION_RESIZE_SOUTHWEST:\n                if (hasValidAspectRatio) {\n                    offsetY = -offsetX / aspectRatio;\n                }\n                x += offsetX;\n                width -= offsetX;\n                height += offsetY;\n                if (width < 0 && height < 0) {\n                    action = ACTION_RESIZE_NORTHEAST;\n                    width = -width;\n                    height = -height;\n                    x -= width;\n                    y -= height;\n                }\n                else if (width < 0) {\n                    action = ACTION_RESIZE_SOUTHEAST;\n                    width = -width;\n                    x -= width;\n                }\n                else if (height < 0) {\n                    action = ACTION_RESIZE_NORTHWEST;\n                    height = -height;\n                    y -= height;\n                }\n                break;\n        }\n        if ($canvas) {\n            $canvas.$setAction(action);\n        }\n        return this.$change(x, y, width, height);\n    }\n    /**\n     * Zooms the selection.\n     * @param {number} scale The zoom factor. Positive numbers for zooming in, and negative numbers for zooming out.\n     * @param {number} [x] The zoom origin in the horizontal, defaults to the center of the selection.\n     * @param {number} [y] The zoom origin in the vertical, defaults to the center of the selection.\n     * @returns {CropperSelection} Returns `this` for chaining.\n     */\n    $zoom(scale, x, y) {\n        if (!this.zoomable || scale === 0) {\n            return this;\n        }\n        if (scale < 0) {\n            scale = 1 / (1 - scale);\n        }\n        else {\n            scale += 1;\n        }\n        const { width, height } = this;\n        const newWidth = width * scale;\n        const newHeight = height * scale;\n        let newX = this.x;\n        let newY = this.y;\n        if (isNumber(x) && isNumber(y)) {\n            newX -= (newWidth - width) * ((x - this.x) / width);\n            newY -= (newHeight - height) * ((y - this.y) / height);\n        }\n        else {\n            // Zoom from the center of the selection\n            newX -= (newWidth - width) / 2;\n            newY -= (newHeight - height) / 2;\n        }\n        return this.$change(newX, newY, newWidth, newHeight);\n    }\n    /**\n     * Changes the position and/or size of the selection.\n     * @param {number} x The new position in the horizontal direction.\n     * @param {number} y The new position in the vertical direction.\n     * @param {number} [width] The new width.\n     * @param {number} [height] The new height.\n     * @param {number} [aspectRatio] The new aspect ratio for this change only.\n     * @param {number} [_force] Force change.\n     * @returns {CropperSelection} Returns `this` for chaining.\n     */\n    $change(x, y, width = this.width, height = this.height, aspectRatio = this.aspectRatio, _force = false) {\n        if (this.$changing\n            || !isNumber(x)\n            || !isNumber(y)\n            || !isNumber(width)\n            || !isNumber(height)\n            || width < 0\n            || height < 0) {\n            return this;\n        }\n        if (isPositiveNumber(aspectRatio)) {\n            ({ width, height } = getAdjustedSizes({ aspectRatio, width, height }, 'cover'));\n        }\n        if (!this.precise) {\n            x = Math.round(x);\n            y = Math.round(y);\n            width = Math.round(width);\n            height = Math.round(height);\n        }\n        if (x === this.x\n            && y === this.y\n            && width === this.width\n            && height === this.height\n            && Object.is(aspectRatio, this.aspectRatio)\n            && !_force) {\n            return this;\n        }\n        if (this.hidden) {\n            this.hidden = false;\n        }\n        if (this.$emit(EVENT_CHANGE, {\n            x,\n            y,\n            width,\n            height,\n        }) === false) {\n            return this;\n        }\n        this.$changing = true;\n        this.x = x;\n        this.y = y;\n        this.width = width;\n        this.height = height;\n        this.$changing = false;\n        return this.$render();\n    }\n    /**\n     * Resets the selection to its initial position and size.\n     * @returns {CropperSelection} Returns `this` for chaining.\n     */\n    $reset() {\n        const { x, y, width, height, } = this.$initialSelection;\n        return this.$change(x, y, width, height);\n    }\n    /**\n     * Clears the selection.\n     * @returns {CropperSelection} Returns `this` for chaining.\n     */\n    $clear() {\n        this.$change(0, 0, 0, 0, NaN, true);\n        this.hidden = true;\n        return this;\n    }\n    /**\n     * Refreshes the position or size of the selection.\n     * @returns {CropperSelection} Returns `this` for chaining.\n     */\n    $render() {\n        return this.$setStyles({\n            transform: `translate(${this.x}px, ${this.y}px)`,\n            width: this.width,\n            height: this.height,\n        });\n    }\n    /**\n     * Generates a real canvas element, with the image (selected area only) draw into if there is one.\n     * @param {object} [options] The available options.\n     * @param {number} [options.width] The width of the canvas.\n     * @param {number} [options.height] The height of the canvas.\n     * @param {Function} [options.beforeDraw] The function called before drawing the image onto the canvas.\n     * @returns {Promise} Returns a promise that resolves to the generated canvas element.\n     */\n    $toCanvas(options) {\n        return new Promise((resolve, reject) => {\n            if (!this.isConnected) {\n                reject(new Error('The current element is not connected to the DOM.'));\n                return;\n            }\n            const canvas = document.createElement('canvas');\n            let { width, height } = this;\n            let scale = 1;\n            if (isPlainObject(options)\n                && (isPositiveNumber(options.width) || isPositiveNumber(options.height))) {\n                ({ width, height } = getAdjustedSizes({\n                    aspectRatio: width / height,\n                    width: options.width,\n                    height: options.height,\n                }));\n                scale = width / this.width;\n            }\n            canvas.width = width;\n            canvas.height = height;\n            if (!this.$canvas) {\n                resolve(canvas);\n                return;\n            }\n            const cropperImage = this.$canvas.querySelector(this.$getTagNameOf(CROPPER_IMAGE));\n            if (!cropperImage) {\n                resolve(canvas);\n                return;\n            }\n            cropperImage.$ready().then((image) => {\n                const context = canvas.getContext('2d');\n                if (context) {\n                    const [a, b, c, d, e, f] = cropperImage.$getTransform();\n                    const offsetX = -this.x;\n                    const offsetY = -this.y;\n                    const translateX = ((offsetX * d) - (c * offsetY)) / ((a * d) - (c * b));\n                    const translateY = ((offsetY * a) - (b * offsetX)) / ((a * d) - (c * b));\n                    let newE = a * translateX + c * translateY + e;\n                    let newF = b * translateX + d * translateY + f;\n                    let destWidth = image.naturalWidth;\n                    let destHeight = image.naturalHeight;\n                    if (scale !== 1) {\n                        newE *= scale;\n                        newF *= scale;\n                        destWidth *= scale;\n                        destHeight *= scale;\n                    }\n                    const centerX = destWidth / 2;\n                    const centerY = destHeight / 2;\n                    context.fillStyle = 'transparent';\n                    context.fillRect(0, 0, width, height);\n                    if (isPlainObject(options) && isFunction(options.beforeDraw)) {\n                        options.beforeDraw.call(this, context, canvas);\n                    }\n                    context.save();\n                    // Move the transform origin to the center of the image.\n                    // https://developer.mozilla.org/en-US/docs/Web/CSS/transform-origin\n                    context.translate(centerX, centerY);\n                    context.transform(a, b, c, d, newE, newF);\n                    // Move the transform origin to the top-left of the image.\n                    context.translate(-centerX, -centerY);\n                    context.drawImage(image, 0, 0, destWidth, destHeight);\n                    context.restore();\n                }\n                resolve(canvas);\n            }).catch(reject);\n        });\n    }\n}\nCropperSelection.$name = CROPPER_SELECTION;\nCropperSelection.$version = '2.0.0';\n\nexport { CropperSelection as default };\n","import CropperElement from '@cropper/element';\nimport { CROPPER_GIRD } from '@cropper/utils';\n\nvar style = `:host{display:flex;flex-direction:column;position:relative;touch-action:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}:host([bordered]){border:1px dashed var(--theme-color)}:host([covered]){bottom:0;left:0;position:absolute;right:0;top:0}:host>span{display:flex;flex:1}:host>span+span{border-top:1px dashed var(--theme-color)}:host>span>span{flex:1}:host>span>span+span{border-left:1px dashed var(--theme-color)}`;\n\nclass CropperGrid extends CropperElement {\n    constructor() {\n        super(...arguments);\n        this.$style = style;\n        this.bordered = false;\n        this.columns = 3;\n        this.covered = false;\n        this.rows = 3;\n        this.slottable = false;\n        this.themeColor = 'rgba(238, 238, 238, 0.5)';\n    }\n    static get observedAttributes() {\n        return super.observedAttributes.concat([\n            'bordered',\n            'columns',\n            'covered',\n            'rows',\n        ]);\n    }\n    $propertyChangedCallback(name, oldValue, newValue) {\n        if (Object.is(newValue, oldValue)) {\n            return;\n        }\n        super.$propertyChangedCallback(name, oldValue, newValue);\n        if (name === 'rows' || name === 'columns') {\n            this.$nextTick(() => {\n                this.$render();\n            });\n        }\n    }\n    connectedCallback() {\n        super.connectedCallback();\n        this.$render();\n    }\n    $render() {\n        const shadow = this.$getShadowRoot();\n        const fragment = document.createDocumentFragment();\n        for (let i = 0; i < this.rows; i += 1) {\n            const row = document.createElement('span');\n            row.setAttribute('role', 'row');\n            for (let j = 0; j < this.columns; j += 1) {\n                const column = document.createElement('span');\n                column.setAttribute('role', 'gridcell');\n                row.appendChild(column);\n            }\n            fragment.appendChild(row);\n        }\n        if (shadow) {\n            shadow.innerHTML = '';\n            shadow.appendChild(fragment);\n        }\n    }\n}\nCropperGrid.$name = CROPPER_GIRD;\nCropperGrid.$version = '2.0.0';\n\nexport { CropperGrid as default };\n","import CropperElement from '@cropper/element';\nimport { CROPPER_CROSSHAIR } from '@cropper/utils';\n\nvar style = `:host{display:inline-block;height:1em;position:relative;touch-action:none;-webkit-user-select:none;-moz-user-select:none;user-select:none;vertical-align:middle;width:1em}:host:after,:host:before{background-color:var(--theme-color);content:\"\";display:block;position:absolute}:host:before{height:1px;left:0;top:50%;transform:translateY(-50%);width:100%}:host:after{height:100%;left:50%;top:0;transform:translateX(-50%);width:1px}:host([centered]){left:50%;position:absolute;top:50%;transform:translate(-50%,-50%)}`;\n\nclass CropperCrosshair extends CropperElement {\n    constructor() {\n        super(...arguments);\n        this.$style = style;\n        this.centered = false;\n        this.slottable = false;\n        this.themeColor = 'rgba(238, 238, 238, 0.5)';\n    }\n    static get observedAttributes() {\n        return super.observedAttributes.concat([\n            'centered',\n        ]);\n    }\n}\nCropperCrosshair.$name = CROPPER_CROSSHAIR;\nCropperCrosshair.$version = '2.0.0';\n\nexport { CropperCrosshair as default };\n","import CropperElement from '@cropper/element';\nimport { CROPPER_VIEWER, CROPPER_SELECTION, isElement, on, EVENT_CHANGE, CROPPER_CANVAS, CROPPER_IMAGE, EVENT_LOAD, EVENT_TRANSFORM, off } from '@cropper/utils';\n\nvar style = `:host{display:block;height:100%;overflow:hidden;position:relative;width:100%}`;\n\nconst canvasCache = new WeakMap();\nconst imageCache = new WeakMap();\nconst selectionCache = new WeakMap();\nconst sourceImageCache = new WeakMap();\nconst RESIZE_BOTH = 'both';\nconst RESIZE_HORIZONTAL = 'horizontal';\nconst RESIZE_VERTICAL = 'vertical';\nconst RESIZE_NONE = 'none';\nclass CropperViewer extends CropperElement {\n    constructor() {\n        super(...arguments);\n        this.$onSelectionChange = null;\n        this.$onSourceImageLoad = null;\n        this.$onSourceImageTransform = null;\n        this.$scale = 1;\n        this.$style = style;\n        this.resize = RESIZE_VERTICAL;\n        this.selection = '';\n        this.slottable = false;\n    }\n    set $image(element) {\n        imageCache.set(this, element);\n    }\n    get $image() {\n        return imageCache.get(this);\n    }\n    set $sourceImage(element) {\n        sourceImageCache.set(this, element);\n    }\n    get $sourceImage() {\n        return sourceImageCache.get(this);\n    }\n    set $canvas(element) {\n        canvasCache.set(this, element);\n    }\n    get $canvas() {\n        return canvasCache.get(this);\n    }\n    set $selection(element) {\n        selectionCache.set(this, element);\n    }\n    get $selection() {\n        return selectionCache.get(this);\n    }\n    static get observedAttributes() {\n        return super.observedAttributes.concat([\n            'resize',\n            'selection',\n        ]);\n    }\n    connectedCallback() {\n        super.connectedCallback();\n        let $selection = null;\n        if (this.selection) {\n            $selection = this.ownerDocument.querySelector(this.selection);\n        }\n        else {\n            $selection = this.closest(this.$getTagNameOf(CROPPER_SELECTION));\n        }\n        if (isElement($selection)) {\n            this.$selection = $selection;\n            this.$onSelectionChange = this.$handleSelectionChange.bind(this);\n            on($selection, EVENT_CHANGE, this.$onSelectionChange);\n            const $canvas = $selection.closest(this.$getTagNameOf(CROPPER_CANVAS));\n            if ($canvas) {\n                this.$canvas = $canvas;\n                const $sourceImage = $canvas.querySelector(this.$getTagNameOf(CROPPER_IMAGE));\n                if ($sourceImage) {\n                    this.$sourceImage = $sourceImage;\n                    this.$image = $sourceImage.cloneNode(true);\n                    this.$getShadowRoot().appendChild(this.$image);\n                    this.$onSourceImageLoad = this.$handleSourceImageLoad.bind(this);\n                    this.$onSourceImageTransform = this.$handleSourceImageTransform.bind(this);\n                    on($sourceImage.$image, EVENT_LOAD, this.$onSourceImageLoad);\n                    on($sourceImage, EVENT_TRANSFORM, this.$onSourceImageTransform);\n                }\n            }\n            this.$render();\n        }\n    }\n    disconnectedCallback() {\n        const { $selection, $sourceImage } = this;\n        if ($selection && this.$onSelectionChange) {\n            off($selection, EVENT_CHANGE, this.$onSelectionChange);\n            this.$onSelectionChange = null;\n        }\n        if ($sourceImage && this.$onSourceImageLoad) {\n            off($sourceImage.$image, EVENT_LOAD, this.$onSourceImageLoad);\n            this.$onSourceImageLoad = null;\n        }\n        if ($sourceImage && this.$onSourceImageTransform) {\n            off($sourceImage, EVENT_TRANSFORM, this.$onSourceImageTransform);\n            this.$onSourceImageTransform = null;\n        }\n        super.disconnectedCallback();\n    }\n    $handleSelectionChange(event) {\n        this.$render(event.detail);\n    }\n    $handleSourceImageLoad() {\n        const { $image, $sourceImage } = this;\n        const oldSrc = $image.getAttribute('src');\n        const newSrc = $sourceImage.getAttribute('src');\n        if (newSrc && newSrc !== oldSrc) {\n            $image.setAttribute('src', newSrc);\n            $image.$ready(() => {\n                setTimeout(() => {\n                    this.$render();\n                }, 50);\n            });\n        }\n    }\n    $handleSourceImageTransform(event) {\n        this.$render(undefined, event.detail.matrix);\n    }\n    $render(selection, matrix) {\n        const { $canvas, $selection } = this;\n        if (!selection && !$selection.hidden) {\n            selection = $selection;\n        }\n        if (!selection || (selection.x === 0\n            && selection.y === 0\n            && selection.width === 0\n            && selection.height === 0)) {\n            selection = {\n                x: 0,\n                y: 0,\n                width: $canvas.offsetWidth,\n                height: $canvas.offsetHeight,\n            };\n        }\n        const { x, y, width, height, } = selection;\n        const styles = {};\n        const { clientWidth, clientHeight } = this;\n        let newWidth = clientWidth;\n        let newHeight = clientHeight;\n        let scale = NaN;\n        switch (this.resize) {\n            case RESIZE_BOTH:\n                scale = 1;\n                newWidth = width;\n                newHeight = height;\n                styles.width = width;\n                styles.height = height;\n                break;\n            case RESIZE_HORIZONTAL:\n                scale = height > 0 ? clientHeight / height : 0;\n                newWidth = width * scale;\n                styles.width = newWidth;\n                break;\n            case RESIZE_VERTICAL:\n                scale = width > 0 ? clientWidth / width : 0;\n                newHeight = height * scale;\n                styles.height = newHeight;\n                break;\n            case RESIZE_NONE:\n            default:\n                if (clientWidth > 0) {\n                    scale = width > 0 ? clientWidth / width : 0;\n                }\n                else if (clientHeight > 0) {\n                    scale = height > 0 ? clientHeight / height : 0;\n                }\n        }\n        this.$scale = scale;\n        this.$setStyles(styles);\n        if (this.$sourceImage) {\n            this.$transformImageByOffset(matrix !== null && matrix !== void 0 ? matrix : this.$sourceImage.$getTransform(), -x, -y);\n        }\n    }\n    $transformImageByOffset(matrix, x, y) {\n        const { $image, $scale, $sourceImage, } = this;\n        if ($sourceImage && $image && $scale >= 0) {\n            const [a, b, c, d, e, f] = matrix;\n            const translateX = ((x * d) - (c * y)) / ((a * d) - (c * b));\n            const translateY = ((y * a) - (b * x)) / ((a * d) - (c * b));\n            const newE = a * translateX + c * translateY + e;\n            const newF = b * translateX + d * translateY + f;\n            $image.$ready((image) => {\n                this.$setStyles.call($image, {\n                    width: image.naturalWidth * $scale,\n                    height: image.naturalHeight * $scale,\n                });\n            });\n            $image.$setTransform(a, b, c, d, newE * $scale, newF * $scale);\n        }\n    }\n}\nCropperViewer.$name = CROPPER_VIEWER;\nCropperViewer.$version = '2.0.0';\n\nexport { RESIZE_BOTH, RESIZE_HORIZONTAL, RESIZE_NONE, RESIZE_VERTICAL, CropperViewer as default };\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","/**\n * ---------------------------------------------------------------------\n *\n * GLPI - Gestionnaire Libre de Parc Informatique\n *\n * http://glpi-project.org\n *\n * @copyright 2015-2025 Teclib' and contributors.\n * @copyright 2003-2014 by the INDEPNET Development Team.\n * @licence   https://www.gnu.org/licenses/gpl-3.0.html\n *\n * ---------------------------------------------------------------------\n *\n * LICENSE\n *\n * This file is part of GLPI.\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <https://www.gnu.org/licenses/>.\n *\n * ---------------------------------------------------------------------\n */\n\nimport Cropper from 'cropperjs';\nwindow.Cropper = Cropper;\n"],"names":[],"sourceRoot":""}